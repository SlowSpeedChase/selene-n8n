# Phase 7.3: Cloud AI Integration - Implementation Plan

**Created:** 2026-01-26  
**Goal:** Implement privacy-preserving cloud AI integration for complex planning tasks  
**Timeline:** 3 weeks (21 implementation tasks)  
**Prerequisites:** Phase 7.2 complete (Claude API service exists)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

---

## Architecture Summary

Smart routing between local Ollama and cloud Claude API:
- **Sanitization layer** removes PII before cloud requests  
- **Query router** decides local vs cloud based on complexity + sensitivity
- **Re-personalizer** adds back personal context to cloud responses
- **Privacy controls** give users transparent control over data sharing

---

## Implementation Tasks

### Week 1: Core Services (Tasks 1-7)

#### Task 1: ContentSanitizerService Foundation
**Estimate:** 4 hours  
**Files:**
- Create: `SeleneChat/Sources/Services/ContentSanitizerService.swift`
- Create: `SeleneChat/Tests/Services/ContentSanitizerServiceTests.swift`

**Requirements:**
- PII detection patterns (emails, phones, names)
- Placeholder generation system
- Sanitization transparency logging
- Three privacy levels: strict/balanced/permissive

**Test First (TDD):**
```swift
// SeleneChat/Tests/Services/ContentSanitizerServiceTests.swift
import XCTest
@testable import SeleneChat

final class ContentSanitizerServiceTests: XCTestCase {
    func testDetectsPII() async throws {
        let sanitizer = ContentSanitizerService()
        let text = "Call John at john@email.com or 555-123-4567"
        
        let result = await sanitizer.sanitize(text, level: .strict)
        
        XCTAssertFalse(result.sanitizedText.contains("John"))
        XCTAssertFalse(result.sanitizedText.contains("john@email.com"))
        XCTAssertFalse(result.sanitizedText.contains("555-123-4567"))
        XCTAssertEqual(result.placeholders.count, 3)
    }
    
    func testPreservesStructure() async throws {
        let sanitizer = ContentSanitizerService()
        let text = "I need to call John about the quarterly planning meeting"
        
        let result = await sanitizer.sanitize(text, level: .balanced)
        
        XCTAssertTrue(result.sanitizedText.contains("quarterly planning meeting"))
        XCTAssert(result.placeholders.keys.contains("John"))
    }
}
```

**Run test (should fail):**
```bash
swift test --filter ContentSanitizerServiceTests
```

**Implement service:**
```swift
// SeleneChat/Sources/Services/ContentSanitizerService.swift
import Foundation
import RegexBuilder

actor ContentSanitizerService {
    enum PrivacyLevel: CaseIterable {
        case strict, balanced, permissive
        
        var description: String {
            switch self {
            case .strict: return "Maximum Privacy"
            case .balanced: return "Balanced"  
            case .permissive: return "Minimum Privacy"
            }
        }
    }
    
    struct SanitizationResult {
        let sanitizedText: String
        let placeholders: [String: String]  // original -> placeholder
        let sensitivityScore: Double        // 0.0 = safe, 1.0 = highly sensitive
        let removedElements: [String]       // what was sanitized
        let canSendToCloud: Bool
    }
    
    // PII Detection Patterns
    private let emailPattern = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/
    private let phonePattern = /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/
    private let namePattern = /\b[A-Z][a-z]+ [A-Z][a-z]+\b/  // Simple name detection
    
    func sanitize(_ text: String, level: PrivacyLevel) async -> SanitizationResult {
        var sanitizedText = text
        var placeholders: [String: String] = [:]
        var removedElements: [String] = []
        var sensitivityScore: Double = 0.0
        
        // Detect and replace emails
        let emails = text.matches(of: emailPattern)
        for match in emails {
            let email = String(text[match.range])
            let placeholder = "EMAIL_\(placeholders.count + 1)"
            placeholders[email] = placeholder
            sanitizedText = sanitizedText.replacingOccurrences(of: email, with: placeholder)
            removedElements.append("email")
            sensitivityScore += 0.3
        }
        
        // Detect and replace phone numbers
        let phones = text.matches(of: phonePattern)
        for match in phones {
            let phone = String(text[match.range])
            let placeholder = "PHONE_\(placeholders.count + 1)"
            placeholders[phone] = placeholder
            sanitizedText = sanitizedText.replacingOccurrences(of: phone, with: placeholder)
            removedElements.append("phone")
            sensitivityScore += 0.3
        }
        
        // Names (basic detection)
        if level == .strict {
            let names = text.matches(of: namePattern)
            for match in names {
                let name = String(text[match.range])
                let placeholder = "PERSON_\(placeholders.count + 1)"
                placeholders[name] = placeholder
                sanitizedText = sanitizedText.replacingOccurrences(of: name, with: placeholder)
                removedElements.append("name")
                sensitivityScore += 0.2
            }
        }
        
        // Apply privacy level thresholds
        let canSendToCloud: Bool
        switch level {
        case .strict: canSendToCloud = sensitivityScore <= 0.2
        case .balanced: canSendToCloud = sensitivityScore <= 0.5
        case .permissive: canSendToCloud = sensitivityScore <= 0.8
        }
        
        return SanitizationResult(
            sanitizedText: sanitizedText,
            placeholders: placeholders,
            sensitivityScore: min(sensitivityScore, 1.0),
            removedElements: removedElements,
            canSendToCloud: canSendToCloud
        )
    }
    
    func analyzeText(_ text: String) async -> Double {
        let result = await sanitize(text, level: .balanced)
        return result.sensitivityScore
    }
}
```

**Verify tests pass:**
```bash
swift test --filter ContentSanitizerServiceTests
```

**Commit:**
```bash
git add SeleneChat/Sources/Services/ContentSanitizerService.swift
git add SeleneChat/Tests/Services/ContentSanitizerServiceTests.swift
git commit -m "feat(privacy): add ContentSanitizerService with PII detection

- Detects emails, phone numbers, names using regex patterns
- Three privacy levels: strict/balanced/permissive  
- Generates placeholders and tracks sensitivity scores
- Returns whether content is safe for cloud processing
- Full test coverage with TDD approach"
```

---

#### Task 2: QueryRouterService Foundation  
**Estimate:** 3 hours  
**Files:**
- Create: `SeleneChat/Sources/Services/QueryRouterService.swift`
- Create: `SeleneChat/Tests/Services/QueryRouterServiceTests.swift`

**Requirements:**
- Query complexity analysis
- Routing decision logic (local vs cloud)
- Integration with existing AIProvider enum
- Reason logging for transparency

**Test First:**
```swift
// SeleneChat/Tests/Services/QueryRouterServiceTests.swift
final class QueryRouterServiceTests: XCTestCase {
    func testRoutesSimpleQueriesLocally() async throws {
        let router = QueryRouterService()
        let query = "What's the weather like?"
        
        let decision = await router.routeQuery(query, userPreference: .cloud, privacyLevel: .balanced)
        
        if case .local(let reason) = decision {
            XCTAssertTrue(reason.contains("simple"))
        } else {
            XCTFail("Should route simple queries locally")
        }
    }
    
    func testRoutesComplexQueriesToCloud() async throws {
        let router = QueryRouterService()
        let query = "Help me create a comprehensive 6-month project plan for launching a new product, including market research phases, development milestones, risk mitigation strategies, resource allocation, and success metrics."
        
        let decision = await router.routeQuery(query, userPreference: .cloud, privacyLevel: .balanced)
        
        if case .cloud(let sanitized, let reason) = decision {
            XCTAssertTrue(reason.contains("complex"))
        } else {
            XCTFail("Should route complex queries to cloud")
        }
    }
}
```

**Implementation:**
```swift
// SeleneChat/Sources/Services/QueryRouterService.swift
actor QueryRouterService {
    enum QueryComplexity: CaseIterable {
        case simple, moderate, complex
        
        var threshold: Double {
            switch self {
            case .simple: return 0.3
            case .moderate: return 0.6  
            case .complex: return 1.0
            }
        }
    }
    
    enum RoutingDecision {
        case local(reason: String)
        case cloud(sanitized: Bool, reason: String)
    }
    
    private let sanitizer = ContentSanitizerService()
    
    // Complexity indicators
    private let complexityKeywords = [
        "comprehensive", "strategic", "detailed", "step-by-step", "multi-phase",
        "pros and cons", "analyze", "compare", "evaluate", "plan", "strategy",
        "timeline", "breakdown", "framework", "methodology", "approach"
    ]
    
    func analyzeComplexity(_ text: String) async -> QueryComplexity {
        let words = text.lowercased().components(separatedBy: .whitespacesAndNewlines)
        let wordCount = words.count
        
        // Count complexity indicators
        let complexityMatches = complexityKeywords.reduce(0) { count, keyword in
            count + (text.lowercased().contains(keyword) ? 1 : 0)
        }
        
        // Score based on length and complexity keywords
        let lengthScore = min(Double(wordCount) / 50.0, 0.5)  // 50+ words = 0.5
        let keywordScore = min(Double(complexityMatches) / 5.0, 0.5)  // 5+ keywords = 0.5
        let totalScore = lengthScore + keywordScore
        
        switch totalScore {
        case 0.0..<0.3: return .simple
        case 0.3..<0.6: return .moderate  
        default: return .complex
        }
    }
    
    func routeQuery(_ text: String, userPreference: AIProvider, privacyLevel: ContentSanitizerService.PrivacyLevel) async -> RoutingDecision {
        // Always respect user's explicit local preference
        if userPreference == .local {
            return .local(reason: "User prefers local processing")
        }
        
        // Analyze query complexity
        let complexity = await analyzeComplexity(text)
        
        // For simple queries, default to local
        if complexity == .simple {
            return .local(reason: "Simple query - local processing sufficient")
        }
        
        // Check if content can be safely sent to cloud
        let sanitizationResult = await sanitizer.sanitize(text, level: privacyLevel)
        
        if !sanitizationResult.canSendToCloud {
            return .local(reason: "Contains sensitive information - keeping local")
        }
        
        // Route complex, non-sensitive queries to cloud
        let needsSanitization = !sanitizationResult.placeholders.isEmpty
        return .cloud(
            sanitized: needsSanitization,
            reason: "Complex \(complexity.rawValue) query - using cloud AI for better results"
        )
    }
}
```

**Test and commit as above...**

---

#### Task 3: RepersonalizationService Foundation
**Estimate:** 3 hours  
**Files:**
- Create: `SeleneChat/Sources/Services/RepersonalizationService.swift`
- Create: `SeleneChat/Tests/Services/RepersonalizationServiceTests.swift`

**Requirements:**
- Restore personal context from placeholders
- Enhance responses with user-specific information
- Maintain response quality and coherence

[Implementation details similar to above...]

---

#### Task 4: Enhanced AIProviderService Integration
**Estimate:** 4 hours  
**Files:**  
- Modify: `SeleneChat/Sources/Services/AIProviderService.swift`
- Modify: `SeleneChat/Tests/Services/AIProviderServiceTests.swift`

**Requirements:**
- Integrate sanitization pipeline  
- Route through QueryRouterService
- Handle re-personalization of responses
- Maintain backward compatibility

---

#### Task 5: Privacy Level Settings Model
**Estimate:** 2 hours
**Files:**
- Create: `SeleneChat/Sources/Models/PrivacySettings.swift`
- Create: `SeleneChat/Tests/Models/PrivacySettingsTests.swift`

---

#### Task 6: Cloud Usage Logging  
**Estimate:** 2 hours
**Files:**
- Create: `SeleneChat/Sources/Services/CloudUsageLogger.swift`
- Create: `SeleneChat/Tests/Services/CloudUsageLoggerTests.swift`

---

#### Task 7: Week 1 Integration Testing
**Estimate:** 3 hours
**Test end-to-end pipeline with sample queries**

---

### Week 2: UI Integration (Tasks 8-14)

#### Task 8: Privacy Level Picker Component
**Estimate:** 3 hours
**Files:**
- Create: `SeleneChat/Sources/Views/Components/PrivacyLevelPicker.swift`

#### Task 9: Query Route Indicator  
**Estimate:** 2 hours
**Files:**
- Create: `SeleneChat/Sources/Views/Components/RouteIndicator.swift`

#### Task 10: Sanitization Transparency View
**Estimate:** 4 hours
**Files:**
- Create: `SeleneChat/Sources/Views/Components/SanitizationTransparencyView.swift`

#### Task 11: Settings Panel Integration
**Estimate:** 3 hours  
**Files:**
- Modify: `SeleneChat/Sources/Views/SettingsView.swift`

#### Task 12: Planning View Integration
**Estimate:** 4 hours
**Files:**
- Modify: `SeleneChat/Sources/Views/PlanningView.swift`

#### Task 13: Message Indicators
**Estimate:** 3 hours
**Files:**  
- Modify: `SeleneChat/Sources/Views/Components/MessageBubble.swift`

#### Task 14: Week 2 UI Testing
**Estimate:** 3 hours
**Manual testing of all UI components**

---

### Week 3: Testing & Deployment (Tasks 15-21)

#### Task 15: Privacy Validation Testing
**Estimate:** 4 hours
**Verify no PII leakage in cloud requests**

#### Task 16: Performance Testing  
**Estimate:** 3 hours
**Measure latency impact of sanitization pipeline**

#### Task 17: Quality Assessment Testing
**Estimate:** 4 hours  
**Compare local vs cloud response quality**

#### Task 18: Edge Case Testing
**Estimate:** 3 hours
**Test error handling, API failures, etc.**

#### Task 19: User Experience Testing
**Estimate:** 3 hours
**Manual testing of complete user workflows**

#### Task 20: Documentation Updates
**Estimate:** 2 hours
**Update project documentation with Phase 7.3 info**

#### Task 21: Deployment & Monitoring Setup
**Estimate:** 2 hours
**Final deployment and monitoring configuration**

---

## Success Criteria

### Privacy Protection
- [ ] Zero PII detected in cloud request logs (verified by audit script)
- [ ] Sanitization transparency shows what was removed  
- [ ] Users can see routing decisions and reasons

### Quality Improvement
- [ ] Complex planning queries show 3x improvement in usefulness
- [ ] Response coherence maintained after re-personalization
- [ ] Local fallback works seamlessly when cloud unavailable

### User Experience  
- [ ] <2s additional latency for cloud requests
- [ ] Clear visual indicators for local vs cloud responses
- [ ] Settings panel allows easy privacy level adjustment
- [ ] No breaking changes to existing workflows

---

## Risk Mitigation

### Privacy Risks
- **PII leakage:** Comprehensive test suite with real-world PII samples
- **Over-sanitization:** Tunable privacy levels with user control
- **Logging exposure:** All sanitization logs stay local, never transmitted

### Technical Risks  
- **API failures:** Graceful degradation to local processing
- **Performance impact:** Async processing and caching strategies
- **Integration complexity:** Maintain backward compatibility throughout

### User Experience Risks
- **Confusion:** Clear visual indicators and transparency features
- **Over-complexity:** Sensible defaults with progressive disclosure
- **Trust issues:** Complete transparency about what data is shared

---

## Post-Implementation

### Monitoring
- Track privacy level usage patterns
- Monitor cloud vs local routing decisions  
- Measure response quality improvements
- Log any sanitization failures or edge cases

### Iteration
- Refine PII detection patterns based on real usage
- Adjust complexity scoring algorithm
- Enhance re-personalization quality
- Add new privacy controls as needed

This plan provides a systematic approach to implementing privacy-preserving cloud AI integration while maintaining the trust and security that Selene users expect.