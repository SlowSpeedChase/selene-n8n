# Phase 7.2: SeleneChat Planning Integration - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add a Planning tab to SeleneChat that enables guided breakdown conversations for `needs_planning` items, using Claude API for planning and Things URL scheme for task creation.

**Architecture:** Dual AI routing (Ollama for sensitive note queries, Claude API for planning conversations). Things 3 is the task database - we only store relationship links. Methodology files control prompts/triggers without code changes.

**Tech Stack:** Swift 5.9+, SwiftUI, SQLite.swift, Claude API, Things URL scheme

---

## Prerequisites

Before starting, ensure:
- [ ] Phase 7.1 complete (`discussion_threads` table exists in database)
- [ ] Things 3 installed with URL scheme enabled (Settings > General > Things URLs)
- [ ] Claude API key available
- [ ] Working in worktree: `.worktrees/selenechat-planning/`

---

## Task 1: Database Migration - Add task_links Table

**Files:**
- Create: `SeleneChat/Sources/Services/Migrations/Migration001_TaskLinks.swift`
- Modify: `SeleneChat/Sources/Services/DatabaseService.swift:89-110`

**Step 1: Create migration file**

Create `SeleneChat/Sources/Services/Migrations/` directory and migration file:

```swift
// SeleneChat/Sources/Services/Migrations/Migration001_TaskLinks.swift
import Foundation
import SQLite

struct Migration001_TaskLinks {
    static func run(db: Connection) throws {
        // Create task_links table
        try db.run("""
            CREATE TABLE IF NOT EXISTS task_links (
                things_task_id TEXT PRIMARY KEY,
                raw_note_id INTEGER,
                discussion_thread_id INTEGER,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (raw_note_id) REFERENCES raw_notes(id),
                FOREIGN KEY (discussion_thread_id) REFERENCES discussion_threads(id)
            )
        """)

        // Create indexes
        try db.run("CREATE INDEX IF NOT EXISTS idx_task_links_thread ON task_links(discussion_thread_id)")
        try db.run("CREATE INDEX IF NOT EXISTS idx_task_links_note ON task_links(raw_note_id)")

        print("✅ Migration 001: task_links table created")
    }
}
```

**Step 2: Run migration to verify it works**

```bash
cd SeleneChat
swift build
```

Expected: Build succeeds

**Step 3: Add migration call to DatabaseService**

In `DatabaseService.swift`, find the `connect()` method around line 74 and add migration call after `createChatSessionsTable()`:

```swift
// In DatabaseService.swift connect() method, after line 82:
try? Migration001_TaskLinks.run(db: db!)
```

**Step 4: Verify migration runs**

```bash
cd SeleneChat
swift build && swift run &
# Wait for app to start, then Ctrl+C
```

Expected: Console shows "✅ Migration 001: task_links table created"

**Step 5: Commit**

```bash
git add SeleneChat/Sources/Services/Migrations/
git add SeleneChat/Sources/Services/DatabaseService.swift
git commit -m "feat(db): add task_links table migration

Links Things tasks to Selene notes and planning threads.
Minimal storage - Things remains the task database."
```

---

## Task 2: Create DiscussionThread Model

**Files:**
- Create: `SeleneChat/Sources/Models/DiscussionThread.swift`
- Create: `SeleneChat/Tests/DiscussionThreadTests.swift`

**Step 1: Write the failing test**

```swift
// SeleneChat/Tests/DiscussionThreadTests.swift
import XCTest
@testable import SeleneChat

final class DiscussionThreadTests: XCTestCase {

    func testThreadInitialization() {
        let thread = DiscussionThread(
            id: 1,
            rawNoteId: 42,
            threadType: .planning,
            prompt: "What's the first step?",
            status: .pending,
            createdAt: Date(),
            relatedConcepts: ["productivity", "goals"]
        )

        XCTAssertEqual(thread.id, 1)
        XCTAssertEqual(thread.rawNoteId, 42)
        XCTAssertEqual(thread.threadType, .planning)
        XCTAssertEqual(thread.status, .pending)
    }

    func testThreadTypeDisplayName() {
        XCTAssertEqual(DiscussionThread.ThreadType.planning.displayName, "Planning")
        XCTAssertEqual(DiscussionThread.ThreadType.followup.displayName, "Follow-up")
        XCTAssertEqual(DiscussionThread.ThreadType.question.displayName, "Question")
    }

    func testThreadStatusIcon() {
        XCTAssertEqual(DiscussionThread.Status.pending.icon, "clock")
        XCTAssertEqual(DiscussionThread.Status.active.icon, "play.circle")
        XCTAssertEqual(DiscussionThread.Status.completed.icon, "checkmark.circle")
    }
}
```

**Step 2: Run test to verify it fails**

```bash
cd SeleneChat
swift test --filter DiscussionThreadTests
```

Expected: FAIL with "cannot find 'DiscussionThread' in scope"

**Step 3: Write the model implementation**

```swift
// SeleneChat/Sources/Models/DiscussionThread.swift
import Foundation

struct DiscussionThread: Identifiable, Hashable {
    let id: Int
    let rawNoteId: Int
    let threadType: ThreadType
    let prompt: String
    var status: Status
    let createdAt: Date
    var surfacedAt: Date?
    var completedAt: Date?
    let relatedConcepts: [String]?
    var resurfaceReason: ResurfaceReason?

    // Associated note content (loaded separately)
    var noteTitle: String?
    var noteContent: String?

    enum ThreadType: String, CaseIterable {
        case planning
        case followup
        case question

        var displayName: String {
            switch self {
            case .planning: return "Planning"
            case .followup: return "Follow-up"
            case .question: return "Question"
            }
        }

        var icon: String {
            switch self {
            case .planning: return "list.bullet.clipboard"
            case .followup: return "arrow.uturn.forward"
            case .question: return "questionmark.circle"
            }
        }
    }

    enum Status: String, CaseIterable {
        case pending
        case active
        case completed
        case dismissed
        case review

        var icon: String {
            switch self {
            case .pending: return "clock"
            case .active: return "play.circle"
            case .completed: return "checkmark.circle"
            case .dismissed: return "xmark.circle"
            case .review: return "arrow.triangle.2.circlepath"
            }
        }

        var color: String {
            switch self {
            case .pending: return "gray"
            case .active: return "blue"
            case .completed: return "green"
            case .dismissed: return "secondary"
            case .review: return "orange"
            }
        }
    }

    enum ResurfaceReason: String {
        case progress = "progress"
        case stuck = "stuck"
        case completion = "completion"

        var message: String {
            switch self {
            case .progress: return "Good progress! Ready to plan next steps?"
            case .stuck: return "This seems stuck. Want to rethink the approach?"
            case .completion: return "All tasks done! Want to reflect or plan what's next?"
            }
        }
    }

    var timeSinceCreated: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: createdAt, relativeTo: Date())
    }
}
```

**Step 4: Run test to verify it passes**

```bash
cd SeleneChat
swift test --filter DiscussionThreadTests
```

Expected: All tests PASS

**Step 5: Commit**

```bash
git add SeleneChat/Sources/Models/DiscussionThread.swift
git add SeleneChat/Tests/DiscussionThreadTests.swift
git commit -m "feat(models): add DiscussionThread model

Represents planning threads from discussion_threads table.
Includes thread types, status states, and resurface reasons."
```

---

## Task 3: Add Thread Queries to DatabaseService

**Files:**
- Modify: `SeleneChat/Sources/Services/DatabaseService.swift`
- Create: `SeleneChat/Tests/DatabaseServiceThreadTests.swift`

**Step 1: Write the failing test**

```swift
// SeleneChat/Tests/DatabaseServiceThreadTests.swift
import XCTest
@testable import SeleneChat

final class DatabaseServiceThreadTests: XCTestCase {

    func testGetPendingThreadsReturnsEmptyArrayWhenNoThreads() async throws {
        let service = DatabaseService.shared

        // This should return empty array, not throw
        let threads = try await service.getPendingThreads()

        // Just verify it returns an array (may be empty or have data)
        XCTAssertNotNil(threads)
    }

    func testGetThreadByIdReturnsNilForNonexistent() async throws {
        let service = DatabaseService.shared

        let thread = try await service.getThread(byId: 999999)

        XCTAssertNil(thread)
    }
}
```

**Step 2: Run test to verify it fails**

```bash
cd SeleneChat
swift test --filter DatabaseServiceThreadTests
```

Expected: FAIL with "has no member 'getPendingThreads'"

**Step 3: Add table definitions to DatabaseService**

In `DatabaseService.swift`, add after line 21 (after existing table definitions):

```swift
// discussion_threads table
private let discussionThreads = Table("discussion_threads")
private let threadId = Expression<Int64>("id")
private let threadRawNoteId = Expression<Int64>("raw_note_id")
private let threadType = Expression<String>("thread_type")
private let threadPrompt = Expression<String>("prompt")
private let threadStatus = Expression<String>("status")
private let threadCreatedAt = Expression<String>("created_at")
private let threadSurfacedAt = Expression<String?>("surfaced_at")
private let threadCompletedAt = Expression<String?>("completed_at")
private let threadRelatedConcepts = Expression<String?>("related_concepts")
private let threadTestRun = Expression<String?>("test_run")
```

**Step 4: Add query methods to DatabaseService**

Add these methods at the end of the DatabaseService class (before the closing brace):

```swift
// MARK: - Discussion Threads

func getPendingThreads() async throws -> [DiscussionThread] {
    guard let db = db else {
        throw DatabaseError.notConnected
    }

    let query = discussionThreads
        .join(.leftOuter, rawNotes, on: discussionThreads[threadRawNoteId] == rawNotes[id])
        .filter(threadStatus == "pending" || threadStatus == "active" || threadStatus == "review")
        .filter(threadTestRun == nil)
        .order(threadCreatedAt.desc)

    var threads: [DiscussionThread] = []

    for row in try db.prepare(query) {
        let thread = try parseThread(from: row)
        threads.append(thread)
    }

    return threads
}

func getThread(byId id: Int) async throws -> DiscussionThread? {
    guard let db = db else {
        throw DatabaseError.notConnected
    }

    let query = discussionThreads
        .join(.leftOuter, rawNotes, on: discussionThreads[threadRawNoteId] == rawNotes[id])
        .filter(threadId == Int64(id))

    guard let row = try db.pluck(query) else {
        return nil
    }

    return try parseThread(from: row)
}

func updateThreadStatus(_ threadId: Int, status: DiscussionThread.Status) async throws {
    guard let db = db else {
        throw DatabaseError.notConnected
    }

    let dateFormatter = ISO8601DateFormatter()
    let now = dateFormatter.string(from: Date())

    let thread = discussionThreads.filter(self.threadId == Int64(threadId))

    var updates: [Setter] = [threadStatus <- status.rawValue]

    if status == .active && threadSurfacedAt == nil {
        updates.append(threadSurfacedAt <- now)
    }

    if status == .completed || status == .dismissed {
        updates.append(threadCompletedAt <- now)
    }

    try db.run(thread.update(updates))

    print("✅ Updated thread \(threadId) status to \(status.rawValue)")
}

private func parseThread(from row: Row) throws -> DiscussionThread {
    let dateFormatter = ISO8601DateFormatter()

    // Parse related concepts JSON
    var conceptsArray: [String]? = nil
    if let conceptsStr = try? row.get(threadRelatedConcepts),
       let data = conceptsStr.data(using: .utf8) {
        conceptsArray = try? JSONDecoder().decode([String].self, from: data)
    }

    // Parse thread type
    let typeStr = try row.get(threadType)
    let threadTypeEnum = DiscussionThread.ThreadType(rawValue: typeStr) ?? .planning

    // Parse status
    let statusStr = try row.get(threadStatus)
    let statusEnum = DiscussionThread.Status(rawValue: statusStr) ?? .pending

    return DiscussionThread(
        id: Int(try row.get(threadId)),
        rawNoteId: Int(try row.get(threadRawNoteId)),
        threadType: threadTypeEnum,
        prompt: try row.get(threadPrompt),
        status: statusEnum,
        createdAt: dateFormatter.date(from: try row.get(threadCreatedAt)) ?? Date(),
        surfacedAt: (try? row.get(threadSurfacedAt)).flatMap { dateFormatter.date(from: $0) },
        completedAt: (try? row.get(threadCompletedAt)).flatMap { dateFormatter.date(from: $0) },
        relatedConcepts: conceptsArray,
        noteTitle: try? row.get(rawNotes[title]),
        noteContent: try? row.get(rawNotes[content])
    )
}
```

**Step 5: Run test to verify it passes**

```bash
cd SeleneChat
swift test --filter DatabaseServiceThreadTests
```

Expected: All tests PASS

**Step 6: Commit**

```bash
git add SeleneChat/Sources/Services/DatabaseService.swift
git add SeleneChat/Tests/DatabaseServiceThreadTests.swift
git commit -m "feat(db): add discussion thread query methods

- getPendingThreads(): Get threads needing attention
- getThread(byId:): Get single thread with note content
- updateThreadStatus(): Update thread lifecycle state"
```

---

## Task 4: Create ClaudeAPIService

**Files:**
- Create: `SeleneChat/Sources/Services/ClaudeAPIService.swift`
- Create: `SeleneChat/Tests/ClaudeAPIServiceTests.swift`

**Step 1: Write the failing test**

```swift
// SeleneChat/Tests/ClaudeAPIServiceTests.swift
import XCTest
@testable import SeleneChat

final class ClaudeAPIServiceTests: XCTestCase {

    func testBuildMessagesFormatsCorrectly() async {
        let service = ClaudeAPIService.shared

        let history: [[String: String]] = [
            ["role": "user", "content": "Hello"],
            ["role": "assistant", "content": "Hi there!"]
        ]

        let messages = service.buildMessages(
            userMessage: "What's next?",
            conversationHistory: history
        )

        XCTAssertEqual(messages.count, 3)
        XCTAssertEqual(messages[0]["role"], "user")
        XCTAssertEqual(messages[0]["content"], "Hello")
        XCTAssertEqual(messages[2]["role"], "user")
        XCTAssertEqual(messages[2]["content"], "What's next?")
    }

    func testExtractTasksFromResponse() {
        let service = ClaudeAPIService.shared

        let response = """
        That's a good starting point.
        [TASK: Research hosting options | energy: low | minutes: 30]
        What else do you need?
        """

        let tasks = service.extractTasks(from: response)

        XCTAssertEqual(tasks.count, 1)
        XCTAssertEqual(tasks[0].title, "Research hosting options")
        XCTAssertEqual(tasks[0].energy, "low")
        XCTAssertEqual(tasks[0].minutes, 30)
    }

    func testExtractMultipleTasks() {
        let service = ClaudeAPIService.shared

        let response = """
        Let me help you break this down:
        [TASK: List requirements | energy: low | minutes: 15]
        [TASK: Compare platforms | energy: medium | minutes: 60]
        Those are good first steps.
        """

        let tasks = service.extractTasks(from: response)

        XCTAssertEqual(tasks.count, 2)
    }
}
```

**Step 2: Run test to verify it fails**

```bash
cd SeleneChat
swift test --filter ClaudeAPIServiceTests
```

Expected: FAIL with "cannot find 'ClaudeAPIService' in scope"

**Step 3: Write the service implementation**

```swift
// SeleneChat/Sources/Services/ClaudeAPIService.swift
import Foundation

struct ExtractedTask {
    let title: String
    let energy: String
    let minutes: Int
}

struct PlanningResponse {
    let message: String
    let extractedTasks: [ExtractedTask]
    let cleanMessage: String  // Message with task markers removed
}

actor ClaudeAPIService {
    static let shared = ClaudeAPIService()

    private let baseURL = "https://api.anthropic.com/v1/messages"
    private let session = URLSession.shared

    private var apiKey: String? {
        ProcessInfo.processInfo.environment["ANTHROPIC_API_KEY"]
    }

    private init() {}

    enum ClaudeError: Error, LocalizedError {
        case missingAPIKey
        case invalidResponse
        case requestFailed(Int, String)
        case networkError(Error)

        var errorDescription: String? {
            switch self {
            case .missingAPIKey:
                return "ANTHROPIC_API_KEY environment variable not set"
            case .invalidResponse:
                return "Invalid response from Claude API"
            case .requestFailed(let status, let message):
                return "Claude API error (\(status)): \(message)"
            case .networkError(let error):
                return "Network error: \(error.localizedDescription)"
            }
        }
    }

    // MARK: - Public Methods

    func sendPlanningMessage(
        userMessage: String,
        conversationHistory: [[String: String]],
        systemPrompt: String
    ) async throws -> PlanningResponse {
        guard let apiKey = apiKey else {
            throw ClaudeError.missingAPIKey
        }

        let messages = buildMessages(
            userMessage: userMessage,
            conversationHistory: conversationHistory
        )

        let requestBody: [String: Any] = [
            "model": "claude-sonnet-4-20250514",
            "max_tokens": 1024,
            "system": systemPrompt,
            "messages": messages
        ]

        var request = URLRequest(url: URL(string: baseURL)!)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(apiKey, forHTTPHeaderField: "x-api-key")
        request.setValue("2023-06-01", forHTTPHeaderField: "anthropic-version")
        request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)
        request.timeoutInterval = 60.0

        do {
            let (data, response) = try await session.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                throw ClaudeError.invalidResponse
            }

            guard httpResponse.statusCode == 200 else {
                let errorMessage = String(data: data, encoding: .utf8) ?? "Unknown error"
                throw ClaudeError.requestFailed(httpResponse.statusCode, errorMessage)
            }

            // Parse response
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                  let content = json["content"] as? [[String: Any]],
                  let firstContent = content.first,
                  let text = firstContent["text"] as? String else {
                throw ClaudeError.invalidResponse
            }

            let extractedTasks = extractTasks(from: text)
            let cleanMessage = removeTaskMarkers(from: text)

            return PlanningResponse(
                message: text,
                extractedTasks: extractedTasks,
                cleanMessage: cleanMessage
            )

        } catch let error as ClaudeError {
            throw error
        } catch {
            throw ClaudeError.networkError(error)
        }
    }

    func isAvailable() async -> Bool {
        return apiKey != nil
    }

    // MARK: - Helper Methods

    func buildMessages(
        userMessage: String,
        conversationHistory: [[String: String]]
    ) -> [[String: String]] {
        var messages = conversationHistory
        messages.append(["role": "user", "content": userMessage])
        return messages
    }

    func extractTasks(from response: String) -> [ExtractedTask] {
        var tasks: [ExtractedTask] = []

        // Pattern: [TASK: title | energy: low/medium/high | minutes: N]
        let pattern = #"\[TASK:\s*([^|]+)\s*\|\s*energy:\s*(low|medium|high)\s*\|\s*minutes:\s*(\d+)\]"#

        guard let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else {
            return tasks
        }

        let range = NSRange(response.startIndex..., in: response)
        let matches = regex.matches(in: response, options: [], range: range)

        for match in matches {
            if let titleRange = Range(match.range(at: 1), in: response),
               let energyRange = Range(match.range(at: 2), in: response),
               let minutesRange = Range(match.range(at: 3), in: response) {

                let title = String(response[titleRange]).trimmingCharacters(in: .whitespaces)
                let energy = String(response[energyRange]).lowercased()
                let minutes = Int(response[minutesRange]) ?? 30

                tasks.append(ExtractedTask(title: title, energy: energy, minutes: minutes))
            }
        }

        return tasks
    }

    func removeTaskMarkers(from response: String) -> String {
        let pattern = #"\[TASK:[^\]]+\]"#

        guard let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else {
            return response
        }

        let range = NSRange(response.startIndex..., in: response)
        return regex.stringByReplacingMatches(
            in: response,
            options: [],
            range: range,
            withTemplate: ""
        ).trimmingCharacters(in: .whitespacesAndNewlines)
    }
}
```

**Step 4: Run test to verify it passes**

```bash
cd SeleneChat
swift test --filter ClaudeAPIServiceTests
```

Expected: All tests PASS

**Step 5: Commit**

```bash
git add SeleneChat/Sources/Services/ClaudeAPIService.swift
git add SeleneChat/Tests/ClaudeAPIServiceTests.swift
git commit -m "feat(services): add ClaudeAPIService for planning conversations

- Calls Claude API with system prompt and conversation history
- Extracts tasks from [TASK: ...] markers in responses
- Returns PlanningResponse with message and extracted tasks"
```

---

## Task 5: Create ThingsURLService

**Files:**
- Create: `SeleneChat/Sources/Services/ThingsURLService.swift`
- Create: `SeleneChat/Tests/ThingsURLServiceTests.swift`

**Step 1: Write the failing test**

```swift
// SeleneChat/Tests/ThingsURLServiceTests.swift
import XCTest
@testable import SeleneChat

final class ThingsURLServiceTests: XCTestCase {

    func testBuildAddTaskURL() {
        let service = ThingsURLService.shared

        let url = service.buildAddTaskURL(
            title: "Test task",
            notes: "Some notes",
            tags: ["selene", "high-energy"],
            sourceNoteId: 42,
            threadId: 7
        )

        XCTAssertNotNil(url)
        XCTAssertTrue(url!.absoluteString.contains("things:///add"))
        XCTAssertTrue(url!.absoluteString.contains("title=Test%20task"))
        XCTAssertTrue(url!.absoluteString.contains("selene"))
    }

    func testBuildAddTaskURLWithSpecialCharacters() {
        let service = ThingsURLService.shared

        let url = service.buildAddTaskURL(
            title: "Task with 'quotes' & ampersand",
            notes: nil,
            tags: [],
            sourceNoteId: nil,
            threadId: nil
        )

        XCTAssertNotNil(url)
        // URL should be properly encoded
        XCTAssertFalse(url!.absoluteString.contains("&a")) // ampersand should be encoded
    }

    func testSeleneMetadataInNotes() {
        let service = ThingsURLService.shared

        let url = service.buildAddTaskURL(
            title: "Test",
            notes: "Original note",
            tags: [],
            sourceNoteId: 42,
            threadId: 7
        )

        XCTAssertNotNil(url)
        // Should contain selene metadata
        XCTAssertTrue(url!.absoluteString.contains("selene"))
        XCTAssertTrue(url!.absoluteString.contains("42"))
        XCTAssertTrue(url!.absoluteString.contains("7"))
    }
}
```

**Step 2: Run test to verify it fails**

```bash
cd SeleneChat
swift test --filter ThingsURLServiceTests
```

Expected: FAIL with "cannot find 'ThingsURLService' in scope"

**Step 3: Write the service implementation**

```swift
// SeleneChat/Sources/Services/ThingsURLService.swift
import Foundation
import AppKit

class ThingsURLService {
    static let shared = ThingsURLService()

    private var authToken: String? {
        ProcessInfo.processInfo.environment["THINGS_AUTH_TOKEN"]
    }

    private init() {}

    enum ThingsError: Error, LocalizedError {
        case invalidURL
        case missingAuthToken
        case openFailed

        var errorDescription: String? {
            switch self {
            case .invalidURL:
                return "Failed to build Things URL"
            case .missingAuthToken:
                return "THINGS_AUTH_TOKEN environment variable not set"
            case .openFailed:
                return "Failed to open Things"
            }
        }
    }

    // MARK: - Public Methods

    /// Build URL for adding a task to Things
    func buildAddTaskURL(
        title: String,
        notes: String? = nil,
        tags: [String] = [],
        sourceNoteId: Int? = nil,
        threadId: Int? = nil,
        deadline: Date? = nil
    ) -> URL? {
        var components = URLComponents(string: "things:///add")
        var queryItems: [URLQueryItem] = []

        // Required: title
        queryItems.append(URLQueryItem(name: "title", value: title))

        // Optional: notes with selene metadata
        var notesContent = notes ?? ""
        if let noteId = sourceNoteId, let tid = threadId {
            if !notesContent.isEmpty {
                notesContent += "\n\n"
            }
            notesContent += "[selene:note-\(noteId):thread-\(tid)]"
        }
        if !notesContent.isEmpty {
            queryItems.append(URLQueryItem(name: "notes", value: notesContent))
        }

        // Tags - always include "selene" tag
        var allTags = tags
        if !allTags.contains("selene") {
            allTags.append("selene")
        }
        queryItems.append(URLQueryItem(name: "tags", value: allTags.joined(separator: ",")))

        // Deadline
        if let deadline = deadline {
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd"
            queryItems.append(URLQueryItem(name: "deadline", value: formatter.string(from: deadline)))
        }

        // Auth token for modifications
        if let token = authToken {
            queryItems.append(URLQueryItem(name: "auth-token", value: token))
        }

        // Don't show quick entry
        queryItems.append(URLQueryItem(name: "show-quick-entry", value: "false"))

        components?.queryItems = queryItems
        return components?.url
    }

    /// Create a task in Things and return success
    func createTask(
        title: String,
        notes: String? = nil,
        tags: [String] = [],
        energy: String? = nil,
        sourceNoteId: Int? = nil,
        threadId: Int? = nil
    ) async throws {
        // Build energy tag if provided
        var allTags = tags
        if let energy = energy {
            allTags.append("\(energy)-energy")
        }

        guard let url = buildAddTaskURL(
            title: title,
            notes: notes,
            tags: allTags,
            sourceNoteId: sourceNoteId,
            threadId: threadId
        ) else {
            throw ThingsError.invalidURL
        }

        // Open Things URL
        let success = await MainActor.run {
            NSWorkspace.shared.open(url)
        }

        if !success {
            throw ThingsError.openFailed
        }

        print("✅ Created task in Things: \(title)")
    }

    /// Open Things to show a specific item
    func showTask(thingsId: String) async throws {
        guard let url = URL(string: "things:///show?id=\(thingsId)") else {
            throw ThingsError.invalidURL
        }

        let success = await MainActor.run {
            NSWorkspace.shared.open(url)
        }

        if !success {
            throw ThingsError.openFailed
        }
    }

    /// Check if Things is installed
    func isThingsInstalled() -> Bool {
        let url = URL(string: "things:///")!
        return NSWorkspace.shared.urlForApplication(toOpen: url) != nil
    }
}
```

**Step 4: Run test to verify it passes**

```bash
cd SeleneChat
swift test --filter ThingsURLServiceTests
```

Expected: All tests PASS

**Step 5: Commit**

```bash
git add SeleneChat/Sources/Services/ThingsURLService.swift
git add SeleneChat/Tests/ThingsURLServiceTests.swift
git commit -m "feat(services): add ThingsURLService for task creation

- Builds Things URL scheme for add/show operations
- Embeds selene metadata in task notes for traceability
- Adds energy-level tags automatically"
```

---

## Task 6: Create Planning Tab Navigation

**Files:**
- Modify: `SeleneChat/Sources/App/ContentView.swift`

**Step 1: Read existing ContentView**

```bash
# Already read - it has Chat and Search navigation items
```

**Step 2: Add Planning navigation item**

In `ContentView.swift`, update the `NavigationItem` enum to add Planning:

```swift
// Replace the existing NavigationItem enum (around line 7-16)
enum NavigationItem: String, CaseIterable {
    case chat = "Chat"
    case search = "Search"
    case planning = "Planning"

    var icon: String {
        switch self {
        case .chat: return "message.fill"
        case .search: return "magnifyingglass"
        case .planning: return "list.bullet.clipboard"
        }
    }
}
```

**Step 3: Add Planning case to detail view**

Update the switch statement in the body (around line 28-33):

```swift
} detail: {
    switch selectedView {
    case .chat:
        ChatView()
    case .search:
        SearchView()
    case .planning:
        PlanningView()
    }
}
```

**Step 4: Build to verify (will fail until PlanningView exists)**

```bash
cd SeleneChat
swift build 2>&1 | head -20
```

Expected: Error about PlanningView not found (we'll create it next)

**Step 5: Commit navigation changes**

```bash
git add SeleneChat/Sources/App/ContentView.swift
git commit -m "feat(nav): add Planning tab to sidebar navigation

Adds third navigation item for planning functionality.
PlanningView implementation coming next."
```

---

## Task 7: Create PlanningView

**Files:**
- Create: `SeleneChat/Sources/Views/PlanningView.swift`

**Step 1: Create the view**

```swift
// SeleneChat/Sources/Views/PlanningView.swift
import SwiftUI

struct PlanningView: View {
    @EnvironmentObject var databaseService: DatabaseService
    @State private var threads: [DiscussionThread] = []
    @State private var selectedThread: DiscussionThread?
    @State private var isLoading = true
    @State private var error: String?

    var body: some View {
        Group {
            if let thread = selectedThread {
                PlanningConversationView(
                    thread: thread,
                    onBack: { selectedThread = nil }
                )
            } else {
                threadListView
            }
        }
        .task {
            await loadThreads()
        }
    }

    private var threadListView: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Planning")
                        .font(.title2)
                        .fontWeight(.semibold)

                    Text("Threads to continue")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }

                Spacer()

                Button(action: { Task { await loadThreads() } }) {
                    Image(systemName: "arrow.clockwise")
                }
                .disabled(isLoading)
            }
            .padding()

            Divider()

            // Content
            if isLoading {
                Spacer()
                ProgressView("Loading threads...")
                Spacer()
            } else if let error = error {
                Spacer()
                VStack(spacing: 12) {
                    Image(systemName: "exclamationmark.triangle")
                        .font(.largeTitle)
                        .foregroundColor(.orange)
                    Text(error)
                        .foregroundColor(.secondary)
                    Button("Try Again") {
                        Task { await loadThreads() }
                    }
                }
                Spacer()
            } else if threads.isEmpty {
                Spacer()
                VStack(spacing: 12) {
                    Image(systemName: "checkmark.circle")
                        .font(.system(size: 48))
                        .foregroundColor(.green)
                    Text("Nothing to plan right now")
                        .font(.headline)
                    Text("Notes flagged as 'needs planning' will appear here")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                }
                .padding()
                Spacer()
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(threads) { thread in
                            PlanningThreadRow(thread: thread)
                                .onTapGesture {
                                    selectedThread = thread
                                }
                        }
                    }
                    .padding()
                }
            }
        }
    }

    private func loadThreads() async {
        isLoading = true
        error = nil

        do {
            threads = try await databaseService.getPendingThreads()
        } catch {
            self.error = error.localizedDescription
        }

        isLoading = false
    }
}

struct PlanningThreadRow: View {
    let thread: DiscussionThread

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header with type badge
            HStack {
                Label(thread.threadType.displayName, systemImage: thread.threadType.icon)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.accentColor.opacity(0.1))
                    .cornerRadius(6)

                Spacer()

                // Status indicator
                HStack(spacing: 4) {
                    Image(systemName: thread.status.icon)
                    Text(thread.timeSinceCreated)
                }
                .font(.caption)
                .foregroundColor(.secondary)
            }

            // Prompt
            Text(thread.prompt)
                .font(.body)
                .lineLimit(2)

            // Note title if available
            if let noteTitle = thread.noteTitle {
                Text("From: \(noteTitle)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }

            // Resurface reason if applicable
            if let reason = thread.resurfaceReason {
                HStack(spacing: 4) {
                    Image(systemName: "arrow.triangle.2.circlepath")
                    Text(reason.message)
                }
                .font(.caption)
                .foregroundColor(.orange)
                .padding(.top, 4)
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(12)
        .contentShape(Rectangle())
    }
}

// Placeholder for conversation view - will be implemented next
struct PlanningConversationView: View {
    let thread: DiscussionThread
    let onBack: () -> Void

    var body: some View {
        VStack {
            HStack {
                Button(action: onBack) {
                    Label("Back to threads", systemImage: "chevron.left")
                }
                Spacer()
            }
            .padding()

            Divider()

            Text("Planning conversation for: \(thread.prompt)")
                .padding()

            Spacer()
        }
    }
}
```

**Step 2: Build and verify**

```bash
cd SeleneChat
swift build
```

Expected: Build succeeds

**Step 3: Commit**

```bash
git add SeleneChat/Sources/Views/PlanningView.swift
git commit -m "feat(views): add PlanningView with thread list

- Shows pending planning threads from database
- Includes type badges, status, and time indicators
- Empty state when nothing to plan
- Placeholder for conversation view"
```

---

## Task 8: Create PlanningConversationView

**Files:**
- Modify: `SeleneChat/Sources/Views/PlanningView.swift` (replace placeholder)

**Step 1: Replace the placeholder PlanningConversationView**

Replace the placeholder `PlanningConversationView` struct at the bottom of `PlanningView.swift`:

```swift
struct PlanningConversationView: View {
    let thread: DiscussionThread
    let onBack: () -> Void

    @EnvironmentObject var databaseService: DatabaseService
    @State private var messages: [PlanningMessage] = []
    @State private var inputText = ""
    @State private var isProcessing = false
    @State private var conversationHistory: [[String: String]] = []
    @State private var tasksCreated: [String] = []
    @FocusState private var isInputFocused: Bool

    private let claudeService = ClaudeAPIService.shared
    private let thingsService = ThingsURLService.shared

    var body: some View {
        VStack(spacing: 0) {
            // Header
            conversationHeader

            Divider()

            // Original note context
            noteContextCard

            Divider()

            // Messages
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 16) {
                        ForEach(messages) { message in
                            PlanningMessageBubble(message: message)
                                .id(message.id)
                        }

                        if isProcessing {
                            HStack {
                                ProgressView()
                                    .scaleEffect(0.8)
                                Text("Thinking...")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            .id("processing")
                        }
                    }
                    .padding()
                }
                .onChange(of: messages.count) {
                    if let lastMessage = messages.last {
                        withAnimation {
                            proxy.scrollTo(lastMessage.id, anchor: .bottom)
                        }
                    }
                }
            }

            Divider()

            // Input
            inputArea
        }
        .task {
            await startConversation()
        }
    }

    private var conversationHeader: some View {
        HStack {
            Button(action: onBack) {
                Label("Back", systemImage: "chevron.left")
            }
            .buttonStyle(.plain)

            Spacer()

            if !tasksCreated.isEmpty {
                HStack(spacing: 4) {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                    Text("\(tasksCreated.count) tasks created")
                        .font(.caption)
                }
            }

            Spacer()

            Button("Complete") {
                Task { await completeThread() }
            }
            .disabled(isProcessing)
        }
        .padding()
    }

    private var noteContextCard: some View {
        VStack(alignment: .leading, spacing: 8) {
            if let title = thread.noteTitle {
                Text(title)
                    .font(.headline)
            }

            if let content = thread.noteContent {
                Text(content)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                    .lineLimit(3)
            }
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color.accentColor.opacity(0.05))
    }

    private var inputArea: some View {
        HStack(alignment: .bottom, spacing: 12) {
            TextField("Your response...", text: $inputText, axis: .vertical)
                .textFieldStyle(.roundedBorder)
                .focused($isInputFocused)
                .lineLimit(1...5)
                .disabled(isProcessing)
                .onSubmit {
                    sendMessage()
                }

            Button(action: sendMessage) {
                Image(systemName: "arrow.up.circle.fill")
                    .font(.title2)
                    .foregroundColor(inputText.isEmpty ? .gray : .accentColor)
            }
            .buttonStyle(.plain)
            .disabled(inputText.isEmpty || isProcessing)
        }
        .padding()
    }

    private func startConversation() async {
        // Mark thread as active
        try? await databaseService.updateThreadStatus(thread.id, status: .active)

        // Add initial AI message based on thread prompt
        let systemPrompt = buildSystemPrompt()

        isProcessing = true

        do {
            let response = try await claudeService.sendPlanningMessage(
                userMessage: "Start the planning session.",
                conversationHistory: [],
                systemPrompt: systemPrompt
            )

            conversationHistory.append(["role": "user", "content": "Start the planning session."])
            conversationHistory.append(["role": "assistant", "content": response.message])

            messages.append(PlanningMessage(
                role: .assistant,
                content: response.cleanMessage
            ))

            // Handle any extracted tasks
            await handleExtractedTasks(response.extractedTasks)

        } catch {
            messages.append(PlanningMessage(
                role: .system,
                content: "Failed to start conversation: \(error.localizedDescription)"
            ))
        }

        isProcessing = false
    }

    private func sendMessage() {
        guard !inputText.isEmpty else { return }

        let userInput = inputText
        inputText = ""

        // Add user message
        messages.append(PlanningMessage(role: .user, content: userInput))
        conversationHistory.append(["role": "user", "content": userInput])

        isProcessing = true

        Task {
            do {
                let response = try await claudeService.sendPlanningMessage(
                    userMessage: userInput,
                    conversationHistory: conversationHistory,
                    systemPrompt: buildSystemPrompt()
                )

                conversationHistory.append(["role": "assistant", "content": response.message])

                messages.append(PlanningMessage(
                    role: .assistant,
                    content: response.cleanMessage
                ))

                // Handle any extracted tasks
                await handleExtractedTasks(response.extractedTasks)

            } catch {
                messages.append(PlanningMessage(
                    role: .system,
                    content: "Error: \(error.localizedDescription)"
                ))
            }

            isProcessing = false
        }
    }

    private func handleExtractedTasks(_ tasks: [ExtractedTask]) async {
        for task in tasks {
            do {
                try await thingsService.createTask(
                    title: task.title,
                    notes: nil,
                    tags: [],
                    energy: task.energy,
                    sourceNoteId: thread.rawNoteId,
                    threadId: thread.id
                )

                tasksCreated.append(task.title)

                // Show confirmation in chat
                messages.append(PlanningMessage(
                    role: .taskCreated,
                    content: task.title
                ))

            } catch {
                messages.append(PlanningMessage(
                    role: .system,
                    content: "Failed to create task: \(error.localizedDescription)"
                ))
            }
        }
    }

    private func completeThread() async {
        try? await databaseService.updateThreadStatus(thread.id, status: .completed)
        onBack()
    }

    private func buildSystemPrompt() -> String {
        """
        You are a planning assistant helping break down goals into actionable tasks.
        Ask ONE question at a time. When the user's response contains a clear,
        specific action, extract it as a task.

        Context:
        - Original note: \(thread.noteContent ?? "No content")
        - Planning prompt: \(thread.prompt)
        - Tasks already created: \(tasksCreated.joined(separator: ", "))

        Your question types (cycle through as needed):
        1. "What's the first concrete step you could take?"
        2. "What's blocking you from starting?"
        3. "Can you break that down smaller?"
        4. "What would 'done' look like for this?"
        5. "What's the next step after that?"

        When extracting a task, include in your response:
        [TASK: verb + object | energy: low/medium/high | minutes: 5/15/30/60/120/240]

        When planning feels complete, ask: "Does this cover what you need,
        or is there more to plan?"
        """
    }
}

// MARK: - Planning Message Model

struct PlanningMessage: Identifiable {
    let id = UUID()
    let role: Role
    let content: String
    let timestamp = Date()

    enum Role {
        case user
        case assistant
        case system
        case taskCreated
    }
}

struct PlanningMessageBubble: View {
    let message: PlanningMessage

    var body: some View {
        HStack {
            if message.role == .user { Spacer() }

            content
                .padding(12)
                .background(backgroundColor)
                .foregroundColor(textColor)
                .cornerRadius(12)

            if message.role != .user { Spacer() }
        }
    }

    @ViewBuilder
    private var content: some View {
        switch message.role {
        case .taskCreated:
            HStack(spacing: 8) {
                Image(systemName: "checkmark.circle.fill")
                    .foregroundColor(.green)
                Text("Task created: \(message.content)")
            }
            .font(.callout)
        default:
            Text(message.content)
        }
    }

    private var backgroundColor: Color {
        switch message.role {
        case .user: return Color.accentColor
        case .assistant: return Color(NSColor.controlBackgroundColor)
        case .system: return Color.orange.opacity(0.2)
        case .taskCreated: return Color.green.opacity(0.1)
        }
    }

    private var textColor: Color {
        message.role == .user ? .white : .primary
    }
}
```

**Step 2: Build and verify**

```bash
cd SeleneChat
swift build
```

Expected: Build succeeds

**Step 3: Commit**

```bash
git add SeleneChat/Sources/Views/PlanningView.swift
git commit -m "feat(views): implement PlanningConversationView

- Full conversation UI with message bubbles
- Integrates ClaudeAPIService for AI responses
- Extracts tasks and creates them in Things
- Shows task creation confirmations inline
- Tracks conversation history for context"
```

---

## Task 9: Create Methodology Files

**Files:**
- Create: `prompts/planning/breakdown-questions.md`
- Create: `prompts/planning/resurface-triggers.yaml`

**Step 1: Create prompts directory and breakdown questions**

```bash
mkdir -p prompts/planning
```

```markdown
<!-- prompts/planning/breakdown-questions.md -->
---
name: guided-breakdown
version: 1.0
---

# Opening Questions
- What's the first concrete step you could take?
- What would help you get started on this?
- Where would you begin if you had 15 minutes right now?

# Clarifying Questions
- Can you break that down into something smaller?
- What would "done" look like for that step?
- Is there anything you need before you can do this?

# Blocker Questions
- What's stopping you from starting right now?
- What do you need before you can do this?
- Is there a decision you need to make first?

# Progress Questions
- What's the next step after that?
- Is there anything else this needs?
- What would you tackle after completing this?

# Completion Check
- Does this cover what you need, or is there more to plan?
- Are you ready to start, or should we break anything down further?
- Is there anything we missed?

# Task Extraction Rules
When the user describes a clear, specific action:
1. It should start with a verb
2. It should have a clear "done" state
3. It should be completable in one session

Format: [TASK: verb + object | energy: low/medium/high | minutes: 5/15/30/60/120/240]
```

**Step 2: Create resurface triggers config**

```yaml
# prompts/planning/resurface-triggers.yaml
version: 1.0

triggers:
  progress:
    threshold_percent: 50
    message: "Good progress! Ready to plan next steps?"
    status: review

  stuck:
    days_inactive: 3
    message: "This seems stuck. Want to rethink the approach?"
    status: review

  completion:
    threshold_percent: 100
    message: "All tasks done! Want to reflect or plan what's next?"
    status: review

defaults:
  check_interval_hours: 1
  require_minimum_tasks: 1
```

**Step 3: Commit methodology files**

```bash
git add prompts/
git commit -m "feat(methodology): add planning prompts and triggers

- breakdown-questions.md: Question sequences for guided breakdown
- resurface-triggers.yaml: Thresholds for thread resurfacing

These files can be edited to evolve planning behavior without code changes."
```

---

## Task 10: Update BRANCH-STATUS.md

**Files:**
- Modify: `BRANCH-STATUS.md`

**Step 1: Update checklist**

Update the checklist in BRANCH-STATUS.md to reflect completed items:

```bash
# Update the file to mark completed items
```

**Step 2: Commit status update**

```bash
git add BRANCH-STATUS.md
git commit -m "docs: update BRANCH-STATUS.md with implementation progress"
```

---

## Next Steps (Phase 7.2d - Bidirectional Flow)

The remaining tasks for bidirectional Things flow:

1. **Task 11:** Add PromptLoader service to read methodology files
2. **Task 12:** Add Things status checking via AppleScript
3. **Task 13:** Implement resurface trigger logic
4. **Task 14:** Add task_links database operations
5. **Task 15:** Integration testing

These can be implemented in a follow-up session after validating Tasks 1-10.

---

## Testing Checklist

After completing Tasks 1-10:

- [ ] App builds successfully: `swift build`
- [ ] Tests pass: `swift test`
- [ ] Planning tab appears in navigation
- [ ] Empty state shows when no threads
- [ ] Thread list loads from database (may be empty)
- [ ] Conversation starts when thread selected
- [ ] Claude API responds (requires ANTHROPIC_API_KEY)
- [ ] Tasks create in Things (requires Things installed)

---

## Environment Setup

Before running the app, set required environment variables:

```bash
export ANTHROPIC_API_KEY="sk-ant-..."
export THINGS_AUTH_TOKEN="..."  # From Things Settings > General > Things URLs
```

Or add to `~/.zshrc` for persistence.
