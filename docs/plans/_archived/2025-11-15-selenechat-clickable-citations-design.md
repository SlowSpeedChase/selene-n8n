# SeleneChat Clickable Citations Design

**Date:** 2025-11-15
**Status:** Design Complete - Ready for Implementation
**Feature:** Make citations clickable links to open notes in Obsidian

---

## Executive Summary

Enhance SeleneChat's citation system to make citations clickable. When users click a citation like `[Note: 'Title' - Date]`, they see the full note details in a sheet, with an "Open in Obsidian" button to launch the note in Obsidian for editing.

---

## Goals

### Primary Goals
1. Make citations in assistant responses clickable
2. Show full note details when citation is clicked
3. Provide "Open in Obsidian" button to launch notes in Obsidian
4. Maintain clean, ADHD-friendly interface

### Success Criteria
- ✅ Citations appear as blue, underlined text in assistant messages
- ✅ Clicking citation opens NoteDetailView sheet with full note content
- ✅ "Open in Obsidian" button successfully launches note in Obsidian
- ✅ Graceful handling when markdown file not found
- ✅ Works with existing citation format from Ollama responses

---

## Current State

### Database
- **Location:** `/Users/chaseeasterling/selene-n8n/data/selene.db`
- **Tables:** `raw_notes`, `processed_notes`
- **Note:** No `file_path` column exists - must search vault by date/title

### Obsidian Vault
- **Location:** `/Users/chaseeasterling/selene-n8n/vault/Selene/`
- **Structure:** `By-Concept/<concept>/<YYYY-MM-DD>-<truncated-title>.md`
- **Vault Name:** "Selene"

### Citation Format
- **Pattern:** `[Note: 'Title' - Date]`
- **Example:** `[Note: 'Morning Routine' - Nov 14]`
- **Generated by:** Ollama in assistant responses

---

## Architecture Overview

### User Flow

```
User clicks citation in chat message
    ↓
CitationTextView handles tap
    ↓
Load cited notes from database
    ↓
Find matching note by title/date
    ↓
Open NoteDetailView sheet
    ↓
ObsidianService looks up markdown file
    ↓
Show "Open in Obsidian" button
    ↓
User clicks → Opens in Obsidian via URI
```

### Component Diagram

```
ChatView
  └─ MessageBubble
      ├─ CitationTextView (for assistant messages)
      │   ├─ Parses citations
      │   ├─ Renders clickable text
      │   └─ Handles taps
      └─ NoteDetailView (sheet)
          ├─ Shows note content
          ├─ ObsidianService.findMarkdownFile()
          └─ "Open in Obsidian" button
              └─ ObsidianService.openInObsidian()
```

---

## Component Specifications

### 1. ObsidianService (New Service)

**Purpose:** Handle all Obsidian vault interactions - file lookup and URI generation.

**File:** `Sources/Services/ObsidianService.swift`

**Interface:**
```swift
class ObsidianService {
    static let shared = ObsidianService()

    private let vaultPath = "/Users/chaseeasterling/selene-n8n/vault/Selene"
    private let vaultName = "Selene"

    /// Find markdown file in vault for a given note
    func findMarkdownFile(for note: Note) async -> URL?

    /// Generate Obsidian URI for a file path
    func generateObsidianURI(for filePath: String) -> URL?

    /// Open note in Obsidian (combines findMarkdownFile + open URI)
    func openInObsidian(note: Note) async -> Bool

    /// Verify note title by parsing frontmatter
    private func verifyNoteTitle(fileURL: URL, expectedTitle: String) async -> Bool
}
```

**File Lookup Algorithm:**
```swift
func findMarkdownFile(for note: Note) async -> URL? {
    // 1. Format note date as YYYY-MM-DD
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    let datePrefix = dateFormatter.string(from: note.createdAt)

    // 2. Search vault recursively for files starting with date
    let fileManager = FileManager.default
    guard let enumerator = fileManager.enumerator(
        at: URL(fileURLWithPath: vaultPath),
        includingPropertiesForKeys: [.nameKey],
        options: [.skipsHiddenFiles]
    ) else { return nil }

    // 3. Find files matching: <datePrefix>-*.md
    for case let fileURL as URL in enumerator {
        let filename = fileURL.lastPathComponent
        if filename.hasPrefix(datePrefix) && filename.hasSuffix(".md") {
            // 4. Verify by checking frontmatter title
            if await verifyNoteTitle(fileURL: fileURL, expectedTitle: note.title) {
                return fileURL
            }
        }
    }

    return nil
}
```

**Frontmatter Verification:**
```swift
private func verifyNoteTitle(fileURL: URL, expectedTitle: String) async -> Bool {
    guard let content = try? String(contentsOf: fileURL) else { return false }

    // Parse YAML frontmatter
    // Look for: title: "Expected Title"
    let lines = content.components(separatedBy: .newlines)
    var inFrontmatter = false

    for line in lines {
        if line.trimmingCharacters(in: .whitespaces) == "---" {
            inFrontmatter.toggle()
            continue
        }

        if inFrontmatter && line.hasPrefix("title:") {
            let titleValue = line
                .replacingOccurrences(of: "title:", with: "")
                .trimmingCharacters(in: .whitespaces)
                .trimmingCharacters(in: CharacterSet(charactersIn: "\""))

            return titleValue == expectedTitle
        }
    }

    return false
}
```

**URI Generation:**
```swift
func generateObsidianURI(for filePath: String) -> URL? {
    // Convert absolute path to relative path within vault
    guard filePath.hasPrefix(vaultPath) else { return nil }

    let relativePath = filePath
        .replacingOccurrences(of: vaultPath + "/", with: "")
        .addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""

    // Format: obsidian://open?vault=<name>&file=<path>
    let uriString = "obsidian://open?vault=\(vaultName)&file=\(relativePath)"
    return URL(string: uriString)
}
```

**Open in Obsidian:**
```swift
func openInObsidian(note: Note) async -> Bool {
    guard let fileURL = await findMarkdownFile(for: note) else {
        return false
    }

    guard let obsidianURI = generateObsidianURI(for: fileURL.path) else {
        return false
    }

    // Open URI using macOS system
    await MainActor.run {
        NSWorkspace.shared.open(obsidianURI)
    }

    return true
}
```

---

### 2. CitationParser (Enhancement)

**Purpose:** Parse citation patterns from text and extract metadata.

**File:** `Sources/Utilities/CitationParser.swift`

**Interface:**
```swift
struct ParsedCitation: Identifiable {
    let id = UUID()
    let noteTitle: String
    let noteDate: String
    let range: Range<String.Index>
    let displayText: String  // Formatted for display: "[Title - Date]"
}

class CitationParser {
    /// Parse text and extract citations
    static func parse(_ text: String) -> (
        plainText: String,
        citations: [ParsedCitation]
    )

    /// Find matching note from list by title and date
    static func findNote(
        for citation: ParsedCitation,
        in notes: [Note]
    ) -> Note?
}
```

**Parsing Implementation:**
```swift
static func parse(_ text: String) -> (plainText: String, citations: [ParsedCitation]) {
    // Regex pattern: [Note: 'Title' - Date]
    let pattern = #"\[Note: '([^']+)' - ([^\]]+)\]"#
    guard let regex = try? NSRegularExpression(pattern: pattern) else {
        return (text, [])
    }

    var citations: [ParsedCitation] = []
    let nsString = text as NSString
    let matches = regex.matches(in: text, range: NSRange(location: 0, length: nsString.length))

    for match in matches {
        let titleRange = match.range(at: 1)
        let dateRange = match.range(at: 2)
        let fullRange = match.range

        let title = nsString.substring(with: titleRange)
        let date = nsString.substring(with: dateRange)

        guard let swiftRange = Range(fullRange, in: text) else { continue }

        let citation = ParsedCitation(
            noteTitle: title,
            noteDate: date,
            range: swiftRange,
            displayText: "[\(title) - \(date)]"
        )
        citations.append(citation)
    }

    return (text, citations)
}
```

**Note Matching:**
```swift
static func findNote(
    for citation: ParsedCitation,
    in notes: [Note]
) -> Note? {
    // Match by title (exact match preferred)
    let exactMatch = notes.first { $0.title == citation.noteTitle }
    if exactMatch != nil { return exactMatch }

    // Fallback: case-insensitive match
    return notes.first {
        $0.title.lowercased() == citation.noteTitle.lowercased()
    }
}
```

---

### 3. CitationTextView (New Component)

**Purpose:** Render message text with clickable inline citations.

**File:** `Sources/Views/CitationTextView.swift`

**Interface:**
```swift
struct CitationTextView: View {
    let content: String
    let citedNoteIds: [Int]
    @Binding var selectedNote: Note?

    @EnvironmentObject var databaseService: DatabaseService
    @State private var textSegments: [TextSegment] = []

    enum TextSegment: Identifiable {
        case text(String)
        case citation(ParsedCitation)

        var id: String {
            switch self {
            case .text(let str): return str
            case .citation(let cit): return cit.id.uuidString
            }
        }
    }

    var body: some View
    private func parseContent()
    private func handleCitationTap(_ citation: ParsedCitation)
    private func loadCitedNotes() async -> [Note]
}
```

**View Implementation:**
```swift
var body: some View {
    Text {
        ForEach(textSegments) { segment in
            switch segment {
            case .text(let str):
                Text(str)
                    .foregroundColor(.primary)

            case .citation(let citation):
                Text(citation.displayText)
                    .foregroundColor(.blue)
                    .underline()
                    .onTapGesture {
                        handleCitationTap(citation)
                    }
            }
        }
    }
    .textSelection(.enabled)
    .task {
        parseContent()
    }
}
```

**Content Parsing:**
```swift
private func parseContent() {
    let (_, citations) = CitationParser.parse(content)

    var segments: [TextSegment] = []
    var currentIndex = content.startIndex

    // Sort citations by position in text
    let sortedCitations = citations.sorted {
        $0.range.lowerBound < $1.range.lowerBound
    }

    for citation in sortedCitations {
        // Add text before citation
        if currentIndex < citation.range.lowerBound {
            let textBefore = String(content[currentIndex..<citation.range.lowerBound])
            segments.append(.text(textBefore))
        }

        // Add citation
        segments.append(.citation(citation))
        currentIndex = citation.range.upperBound
    }

    // Add remaining text
    if currentIndex < content.endIndex {
        let remainingText = String(content[currentIndex...])
        segments.append(.text(remainingText))
    }

    textSegments = segments
}
```

**Citation Tap Handler:**
```swift
private func handleCitationTap(_ citation: ParsedCitation) {
    Task {
        // Load all cited notes from database
        let notes = await loadCitedNotes()

        // Find matching note
        if let note = CitationParser.findNote(for: citation, in: notes) {
            await MainActor.run {
                selectedNote = note
            }
        }
    }
}

private func loadCitedNotes() async -> [Note] {
    var notes: [Note] = []
    for noteId in citedNoteIds {
        if let note = try? await databaseService.getNote(id: noteId) {
            notes.append(note)
        }
    }
    return notes
}
```

---

### 4. MessageBubble Update

**Purpose:** Use CitationTextView for assistant messages with citations.

**File:** `Sources/Views/ChatView.swift`

**Updated MessageBubble:**
```swift
struct MessageBubble: View {
    let message: Message
    @State private var selectedNote: Note?

    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            if message.role == .assistant {
                assistantIcon
            } else {
                Spacer()
            }

            VStack(alignment: message.role == .user ? .trailing : .leading, spacing: 4) {
                // Message content with clickable citations
                if message.role == .assistant,
                   let citedNotes = message.relatedNotes,
                   !citedNotes.isEmpty {
                    CitationTextView(
                        content: message.content,
                        citedNoteIds: citedNotes,
                        selectedNote: $selectedNote
                    )
                    .padding(12)
                    .background(backgroundColor)
                    .cornerRadius(12)
                } else {
                    Text(message.content)
                        .padding(12)
                        .background(backgroundColor)
                        .foregroundColor(textColor)
                        .cornerRadius(12)
                        .textSelection(.enabled)
                }

                // Metadata (existing)
                HStack(spacing: 8) {
                    if message.role == .assistant {
                        tierBadge
                    }

                    Text(message.formattedTime)
                        .font(.caption2)
                        .foregroundColor(.secondary)

                    if let noteIds = message.relatedNotes, !noteIds.isEmpty {
                        HStack(spacing: 2) {
                            Image(systemName: "doc.text")
                                .font(.caption2)
                            Text("\(noteIds.count)")
                                .font(.caption2)
                        }
                        .foregroundColor(.secondary)
                    }
                }
            }

            if message.role == .user {
                userIcon
            } else {
                Spacer()
            }
        }
        .sheet(item: $selectedNote) { note in
            NoteDetailView(note: note)
        }
    }

    // ... existing properties (backgroundColor, icons, etc.)
}
```

---

### 5. NoteDetailView Enhancement

**Purpose:** Add "Open in Obsidian" button to note details.

**File:** `Sources/Views/NoteDetailView.swift`

**Updated View:**
```swift
struct NoteDetailView: View {
    let note: Note
    @Environment(\.dismiss) var dismiss
    @State private var obsidianFilePath: String?
    @State private var isLookingUpFile = true
    @State private var lookupFailed = false

    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Title
                    Text(note.title)
                        .font(.title)

                    // Date
                    Text(note.createdAt, style: .date)
                        .font(.caption)
                        .foregroundColor(.secondary)

                    Divider()

                    // Content
                    Text(note.content)
                        .font(.body)
                        .textSelection(.enabled)

                    // Metadata sections (if available)
                    if let concepts = note.concepts {
                        MetadataSection(title: "Concepts", items: concepts)
                    }

                    if let theme = note.primaryTheme {
                        MetadataSection(title: "Theme", items: [theme])
                    }

                    if let sentiment = note.overallSentiment {
                        SentimentSection(
                            sentiment: sentiment,
                            score: note.sentimentScore,
                            tone: note.emotionalTone,
                            energy: note.energyLevel
                        )
                    }

                    // File not found message
                    if lookupFailed {
                        HStack {
                            Image(systemName: "exclamationmark.triangle")
                                .foregroundColor(.orange)
                            Text("Note file not found in vault")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.top, 8)
                    }
                }
                .padding()
            }
            .navigationTitle("Note Details")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Done") { dismiss() }
                }

                ToolbarItem(placement: .primaryAction) {
                    if isLookingUpFile {
                        ProgressView()
                            .controlSize(.small)
                    } else if obsidianFilePath != nil {
                        Button {
                            Task {
                                let success = await ObsidianService.shared.openInObsidian(note: note)
                                if !success {
                                    lookupFailed = true
                                }
                            }
                        } label: {
                            Label("Open in Obsidian", systemImage: "link")
                        }
                    }
                }
            }
        }
        .task {
            // Look up file path when view appears
            if let fileURL = await ObsidianService.shared.findMarkdownFile(for: note) {
                obsidianFilePath = fileURL.path
            } else {
                lookupFailed = true
            }
            isLookingUpFile = false
        }
    }
}

// Helper views
struct MetadataSection: View {
    let title: String
    let items: [String]

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(title)
                .font(.caption)
                .fontWeight(.semibold)
                .foregroundColor(.secondary)

            FlowLayout(spacing: 4) {
                ForEach(items, id: \.self) { item in
                    Text(item)
                        .font(.caption)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.accentColor.opacity(0.2))
                        .cornerRadius(4)
                }
            }
        }
    }
}

struct SentimentSection: View {
    let sentiment: String
    let score: Double?
    let tone: String?
    let energy: String?

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("Sentiment")
                .font(.caption)
                .fontWeight(.semibold)
                .foregroundColor(.secondary)

            HStack(spacing: 8) {
                Text(sentiment.capitalized)
                    .font(.caption)

                if let score = score {
                    Text(String(format: "%.1f", score))
                        .font(.caption)
                        .foregroundColor(.secondary)
                }

                if let tone = tone {
                    Text("• \(tone)")
                        .font(.caption)
                }

                if let energy = energy {
                    Text("• \(energy)")
                        .font(.caption)
                }
            }
        }
    }
}
```

---

## Implementation Plan

### Phase 1: ObsidianService Foundation (Days 1-2)
1. Create `Sources/Services/ObsidianService.swift`
2. Implement `findMarkdownFile()` with date-based search
3. Implement frontmatter parsing for title verification
4. Implement `generateObsidianURI()`
5. Implement `openInObsidian()`
6. Write unit tests for file lookup logic

### Phase 2: Citation Parsing Enhancement (Day 2)
7. Create `Sources/Utilities/CitationParser.swift`
8. Implement regex-based citation parsing
9. Implement `findNote()` matching logic
10. Write unit tests for parsing and matching

### Phase 3: UI Components (Days 3-4)
11. Create `Sources/Views/CitationTextView.swift`
12. Implement text segment parsing
13. Implement citation tap handling
14. Update `MessageBubble` in `ChatView.swift`
15. Test citation rendering and click handling

### Phase 4: NoteDetailView Enhancement (Day 4)
16. Update `NoteDetailView` with Obsidian button
17. Add file lookup task on view appearance
18. Add loading and error states
19. Create helper views (MetadataSection, SentimentSection)

### Phase 5: Integration & Testing (Day 5)
20. Ensure `Message.relatedNotes` is populated in ChatViewModel
21. End-to-end testing: citation click → sheet → Obsidian
22. Test error cases (file not found, Obsidian not installed)
23. Performance testing with multiple citations
24. Manual testing checklist completion

---

## Testing Strategy

### Unit Tests

**CitationParserTests.swift:**
```swift
func testParseSingleCitation()
func testParseMultipleCitations()
func testNoCitationsInText()
func testMalformedCitations()
func testFindNoteByTitle()
func testFindNoteByTitleCaseInsensitive()
```

**ObsidianServiceTests.swift:**
```swift
func testFindMarkdownFileByDate()
func testGenerateObsidianURI()
func testHandleMissingFile()
func testFrontmatterParsing()
func testRelativePathConversion()
```

### Manual Testing Checklist

- [ ] Citation appears as blue underlined text in assistant messages
- [ ] Clicking citation opens NoteDetailView sheet
- [ ] NoteDetailView shows correct note content and metadata
- [ ] "Open in Obsidian" button appears after file lookup
- [ ] Loading spinner shows during file lookup
- [ ] Clicking "Open in Obsidian" opens correct note in Obsidian app
- [ ] Multiple citations in same message all work
- [ ] Error message shows when file not found
- [ ] Graceful fallback when Obsidian not installed
- [ ] Works with different date formats in citations
- [ ] Text selection still works in message bubbles

---

## Edge Cases & Error Handling

### File Not Found in Vault

**Scenario:** Database has note but markdown file missing/moved

**Handling:**
```swift
// In NoteDetailView
if lookupFailed && !isLookingUpFile {
    HStack {
        Image(systemName: "exclamationmark.triangle")
        Text("Note file not found in vault")
            .font(.caption)
            .foregroundColor(.secondary)
    }
}
```

### Multiple Files Match Date

**Scenario:** Two notes created on same date

**Handling:**
- Use frontmatter title verification to find exact match
- Fall back to first match if frontmatter parsing fails
- Log warning for debugging

### Obsidian Not Installed

**Scenario:** User clicks "Open in Obsidian" but app not installed

**Handling:**
- macOS will show system alert: "No application to open URL"
- This is acceptable user feedback
- No additional error handling needed

### Citation Parse Failure

**Scenario:** Malformed citation or unexpected format

**Handling:**
- CitationTextView falls back to plain text
- User sees message, just without clickable citations
- Log warning for debugging

### Citation Doesn't Match Any Note

**Scenario:** Citation references note that's not in relatedNotes list

**Handling:**
```swift
// In CitationTextView.handleCitationTap()
if let note = CitationParser.findNote(for: citation, in: notes) {
    selectedNote = note
} else {
    // Silent failure - citation just doesn't open anything
    print("Warning: No matching note found for citation: \(citation.noteTitle)")
}
```

---

## Performance Considerations

### File Lookup Optimization

**Current Approach:**
- Search vault recursively for each note detail view
- Parse frontmatter to verify title match

**Performance:**
- Vault size: ~100-500 markdown files
- Search time: ~50-200ms on modern SSD
- Acceptable for on-demand lookup

**Future Optimization:**
- Cache file paths after first lookup
- Build index of vault files on app launch
- Out of scope for initial implementation

### Citation Parsing

**Complexity:** O(n) where n = message length
**Performance:** ~1ms for typical message (500 chars)
**Optimization:** Parse only once when view loads

### Multiple Citations

**Scenario:** Message with 5-10 citations

**Handling:**
- All citations parsed in single pass
- Each tap loads notes independently
- No noticeable performance impact

---

## Dependencies

### Existing Systems
- ✅ DatabaseService with `getNote(id:)` method
- ✅ Note model with all metadata fields
- ✅ Message model with `relatedNotes` field
- ✅ Ollama generating citations in responses
- ✅ Obsidian vault at `/Users/chaseeasterling/selene-n8n/vault/Selene/`

### New Dependencies
- None - uses Swift standard library and SwiftUI
- Obsidian URI scheme (external, requires Obsidian app installed)

### Requirements
- macOS 14.0+ (existing requirement)
- Obsidian installed and configured
- Vault at expected path

---

## Future Enhancements (Out of Scope)

### Not in This Phase
- ❌ Cache file path lookups
- ❌ Configurable vault path in settings
- ❌ Fuzzy matching for file lookup
- ❌ Preview note on citation hover
- ❌ Batch file lookup for performance
- ❌ Edit note content directly in SeleneChat
- ❌ Sync changes back to vault
- ❌ Support for multiple vaults

### Possible Future Features
- Highlight citation on scroll if note detail already open
- "Copy note link" button for sharing
- Recently viewed notes history
- Citation analytics (most referenced notes)
- Quick preview tooltip on hover

---

## Success Metrics

### Functional Success
- ✅ All citations in assistant messages are clickable
- ✅ NoteDetailView shows correct note 95%+ of the time
- ✅ "Open in Obsidian" successfully launches notes
- ✅ Zero crashes from citation interactions

### User Experience Success
- ✅ Citations feel natural and not intrusive
- ✅ Click → note detail feels instant (<200ms)
- ✅ File lookup completes in <500ms
- ✅ Error states are clear and helpful

### Technical Success
- ✅ File lookup works for 95%+ of notes
- ✅ Citation parsing handles malformed input gracefully
- ✅ No memory leaks from repeated lookups
- ✅ Unit test coverage >80%

---

## Documentation Updates Needed

After implementation:
1. Update SeleneChat README with citation feature
2. Add "Opening Notes in Obsidian" section to user guide
3. Document vault path requirement
4. Add troubleshooting for missing files
5. Update architecture diagram with new components

---

## Conclusion

This design enhances SeleneChat's existing citation system by making citations interactive. Users can click any citation to see full note details, then optionally open the note in Obsidian for editing. The implementation leverages Obsidian's URI scheme and file system search to bridge the gap between the database and vault.

The design maintains SeleneChat's ADHD-friendly interface by:
- Keeping citations visually subtle (blue underline)
- Using familiar sheet presentation for note details
- Providing clear loading and error states
- Making "Open in Obsidian" optional, not forced

All components are testable, and the architecture builds on existing DatabaseService and Message models. Ready for implementation.
