{
  "name": "TEST-02-LLM-Processing-Apple | Selene",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "GET",
        "path": "api/apple/get-pending-note",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-get-pending",
      "name": "Webhook: Get Pending Note",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "selene-apple-get-pending"
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  // Get next pending note for Apple processing and lock it\n  const selectQuery = `SELECT id, title, content, created_at\n                       FROM raw_notes\n                       WHERE status_apple = 'pending_apple'\n                       ORDER BY created_at ASC\n                       LIMIT 1`;\n  \n  const result = db.prepare(selectQuery).all();\n  \n  if (result.length > 0) {\n    const noteId = result[0].id;\n    \n    // Mark as 'processing_apple' to prevent duplicate processing\n    const updateQuery = `UPDATE raw_notes \n                        SET status_apple = 'processing_apple' \n                        WHERE id = ? AND status_apple = 'pending_apple'`;\n    \n    const changes = db.prepare(updateQuery).run(noteId);\n    \n    db.close();\n    \n    // Only proceed if we successfully locked it\n    if (changes.changes > 0) {\n      return result.map(row => ({ json: row }));\n    } else {\n      db.close();\n      return [{ json: { error: 'Note was already picked up by another process', noteId: noteId } }];\n    }\n  } else {\n    db.close();\n    return [{ json: { message: 'No pending notes for Apple processing', hasPendingNotes: false } }];\n  }\n  \n} catch (error) {\n  console.error('SQLite Error:', error);\n  throw new Error('Database query failed: ' + error.message);\n}"
      },
      "id": "function-get-and-lock",
      "name": "Get Note and Lock",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.hasPendingNotes }}",
              "value2": false
            }
          ]
        }
      },
      "id": "if-no-pending",
      "name": "Check if Note Found",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "return {\n  json: {\n    message: 'No pending notes for Apple processing',\n    hasPendingNotes: false,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "function-no-pending-response",
      "name": "Build No Pending Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-no-pending",
      "name": "Respond: No Pending",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "functionCode": "const content = $json.content;\nconst title = $json.title;\nconst noteId = $json.id;\n\n// Detect note type based on keywords\nfunction detectNoteType(text) {\n  const lower = text.toLowerCase();\n\n  if (/(meeting|met with|discussed|decided|action items)/i.test(lower)) {\n    return 'meeting';\n  } else if (/(docker|api|database|code|function|git|python|javascript)/i.test(lower)) {\n    return 'technical';\n  } else if (/(idea|concept|what if|could we|brainstorm)/i.test(lower)) {\n    return 'idea';\n  } else if (/(i feel|i think|my goal|personally|overwhelmed|feeling)/i.test(lower)) {\n    return 'personal';\n  } else if (/(todo|must do|deadline|task|complete)/i.test(lower)) {\n    return 'task';\n  } else if (/(learned|realized|thinking about|reflecting)/i.test(lower)) {\n    return 'reflection';\n  }\n  return 'general';\n}\n\nconst noteType = detectNoteType(content);\n\n// Context-specific guidance\nconst contextGuidance = {\n  meeting: 'This is a MEETING note. Focus on decisions made, action items, people involved, topics discussed, deadlines, and outcomes.',\n  technical: 'This is a TECHNICAL note. Focus on technologies, tools, methods, problems, solutions, and technical concepts discussed.',\n  idea: 'This is an IDEA note. Focus on the core idea, implementation methods, challenges, benefits, and related concepts.',\n  personal: 'This is a PERSONAL note. Focus on activities, goals, challenges, areas of focus, and actionable items rather than emotions.',\n  task: 'This is a TASK note. Focus on the main task, subtasks, tools needed, people involved, and deadlines.',\n  reflection: 'This is a REFLECTION note. Focus on topics being reflected upon, lessons learned, areas for improvement, and actionable insights.',\n  general: 'This is a GENERAL note. Focus on the main topics, subjects, activities, and key points discussed.'\n};\n\n// Standard theme vocabulary\nconst standardThemes = [\n  'work', 'meeting', 'project', 'task', 'personal', 'health',\n  'learning', 'reflection', 'idea', 'problem_solving', 'planning',\n  'technical', 'tools', 'process', 'communication', 'collaboration',\n  'feedback', 'improvement', 'decision', 'notes'\n];\n\nconst contentPreview = content.substring(0, 2000);\n\n// Build ONE mega-prompt that requests all three analyses\nconst combinedPrompt = `You are an expert note analysis AI. Analyze the following note and provide a comprehensive analysis in THREE parts:\n\n${contextGuidance[noteType]}\n\n## PART 1: CONCEPT EXTRACTION\nExtract 3-5 of the most important concepts from the text.\n- Focus on concrete topics, themes, and subjects discussed (not abstract feelings)\n- Concepts should be 1-4 words each (short, meaningful phrases)\n- Provide confidence scores (0.0-1.0) for each concept\n\n## PART 2: THEME DETECTION\nIdentify themes from this note.\n- ONE primary theme (most prominent category)\n- 1-2 secondary themes (distinctly different from primary)\n- Use these standard themes when possible: ${standardThemes.join(', ')}\n- Provide overall theme confidence score (0.0-1.0)\n\n## PART 3: SENTIMENT ANALYSIS\nAnalyze the emotional tone and sentiment.\n- Overall sentiment: positive, negative, or neutral\n- Sentiment score: -1.0 (very negative) to 1.0 (very positive), 0 is neutral\n- Emotional tone: optimistic, concerned, excited, frustrated, reflective, matter-of-fact, anxious, content, motivated, overwhelmed, etc.\n- Energy level: high, medium, or low\n\n## NOTE TO ANALYZE:\n\n${contentPreview}\n\n## REQUIRED OUTPUT FORMAT:\n\nReturn ONLY valid JSON in this EXACT format (no other text, explanations, or markdown formatting):\n\n{\n  \"concepts\": [\"concept1\", \"concept2\", \"concept3\"],\n  \"concept_confidence\": {\"concept1\": 0.95, \"concept2\": 0.85, \"concept3\": 0.75},\n  \"primary_theme\": \"main_theme\",\n  \"secondary_themes\": [\"theme2\", \"theme3\"],\n  \"theme_confidence\": 0.87,\n  \"overall_sentiment\": \"positive\",\n  \"sentiment_score\": 0.7,\n  \"emotional_tone\": \"motivated\",\n  \"energy_level\": \"high\"\n}\n\nRemember: Return ONLY the JSON object, nothing else.`;\n\nreturn {\n  json: {\n    noteId: noteId,\n    title: title,\n    content: content,\n    noteType: noteType,\n    hasPendingNotes: true,\n    prompt: combinedPrompt\n  }\n};"
      },
      "id": "function-build-combined-prompt",
      "name": "Build Combined Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-with-prompt",
      "name": "Respond with Note and Prompt",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1050, 400]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/apple/save-processed-note",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-save-processed",
      "name": "Webhook: Save Processed Note",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 700],
      "webhookId": "selene-apple-save-processed"
    },
    {
      "parameters": {
        "functionCode": "// Get data from webhook payload\nconst body = $input.item.json.body || $input.item.json;\n\nconst noteId = body.noteId;\nconst rawResponse = body.rawResponse || '';\n\nif (!noteId) {\n  throw new Error('noteId is required in webhook payload');\n}\n\nif (!rawResponse) {\n  throw new Error('rawResponse is required in webhook payload');\n}\n\n// Parse the raw response from Apple Intelligence\nlet concepts = [];\nlet conceptConfidence = {};\nlet primaryTheme = 'notes';\nlet secondaryThemes = [];\nlet themeConfidence = 0.5;\nlet overallSentiment = 'neutral';\nlet sentimentScore = 0.0;\nlet emotionalTone = 'matter-of-fact';\nlet energyLevel = 'medium';\nlet parsingMethod = 'unknown';\n\n// Try to parse as JSON first\ntry {\n  // Strip markdown code blocks if present\n  let cleanedResponse = rawResponse.trim();\n  if (cleanedResponse.startsWith('```json')) {\n    cleanedResponse = cleanedResponse.replace(/```json\\n?/g, '').replace(/```\\n?$/g, '');\n  } else if (cleanedResponse.startsWith('```')) {\n    cleanedResponse = cleanedResponse.replace(/```\\n?/g, '');\n  }\n  \n  const parsed = JSON.parse(cleanedResponse);\n  \n  // Extract concepts\n  if (parsed.concepts && Array.isArray(parsed.concepts)) {\n    concepts = parsed.concepts.slice(0, 5);\n    parsingMethod = 'json_success';\n  }\n  \n  // Extract concept confidence\n  if (parsed.concept_confidence && typeof parsed.concept_confidence === 'object') {\n    conceptConfidence = parsed.concept_confidence;\n  } else if (parsed.confidence_scores && typeof parsed.confidence_scores === 'object') {\n    conceptConfidence = parsed.confidence_scores;\n  } else {\n    // Generate default confidence scores\n    concepts.forEach((concept, idx) => {\n      conceptConfidence[concept] = 0.8 - (idx * 0.1);\n    });\n  }\n  \n  // Extract themes\n  if (parsed.primary_theme) {\n    primaryTheme = parsed.primary_theme.toLowerCase().replace(/\\s+/g, '_');\n  }\n  \n  if (parsed.secondary_themes && Array.isArray(parsed.secondary_themes)) {\n    secondaryThemes = parsed.secondary_themes\n      .map(t => t.toLowerCase().replace(/\\s+/g, '_'))\n      .slice(0, 2)\n      .filter(t => t !== primaryTheme);\n  }\n  \n  if (typeof parsed.theme_confidence === 'number') {\n    themeConfidence = parsed.theme_confidence;\n  } else if (typeof parsed.confidence === 'number') {\n    themeConfidence = parsed.confidence;\n  }\n  \n  // Extract sentiment\n  if (parsed.overall_sentiment) {\n    overallSentiment = parsed.overall_sentiment.toLowerCase();\n  }\n  \n  if (typeof parsed.sentiment_score === 'number') {\n    sentimentScore = parsed.sentiment_score;\n  }\n  \n  if (parsed.emotional_tone) {\n    emotionalTone = parsed.emotional_tone.toLowerCase();\n  }\n  \n  if (parsed.energy_level) {\n    energyLevel = parsed.energy_level.toLowerCase();\n  }\n  \n} catch (jsonError) {\n  console.log('JSON parsing failed, attempting fallback extraction:', jsonError.message);\n  parsingMethod = 'fallback_extraction';\n  \n  // Fallback: Try to extract data from text\n  const lines = rawResponse.split('\\n');\n  \n  // Look for concepts (bulleted or numbered lists)\n  for (const line of lines) {\n    const bulletMatch = line.match(/^[-*â€¢]\\s*(.+)$/);\n    const numberMatch = line.match(/^\\d+\\.?\\s*(.+)$/);\n    const match = bulletMatch || numberMatch;\n    \n    if (match) {\n      const concept = match[1].trim().replace(/[.,!?;:]+$/, '');\n      if (concept.split(' ').length <= 4 && concept.length > 2) {\n        concepts.push(concept);\n        conceptConfidence[concept] = 0.6;\n      }\n    }\n    if (concepts.length >= 5) break;\n  }\n  \n  // Look for themes\n  const themeMatch = rawResponse.match(/theme[:\\s]*[\"']?([a-z_]+)[\"']?/i);\n  if (themeMatch) {\n    primaryTheme = themeMatch[1].toLowerCase().replace(/\\s+/g, '_');\n  }\n  \n  // Look for sentiment\n  const sentimentMatch = rawResponse.match(/sentiment[:\\s]*[\"']?(positive|negative|neutral)[\"']?/i);\n  if (sentimentMatch) {\n    overallSentiment = sentimentMatch[1].toLowerCase();\n    // Estimate score based on sentiment\n    if (overallSentiment === 'positive') sentimentScore = 0.5;\n    else if (overallSentiment === 'negative') sentimentScore = -0.5;\n    else sentimentScore = 0.0;\n  }\n  \n  // If still no concepts, try to extract capitalized phrases\n  if (concepts.length === 0) {\n    const capWords = rawResponse.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g) || [];\n    concepts = [...new Set(capWords)].slice(0, 5);\n    concepts.forEach(c => conceptConfidence[c] = 0.4);\n  }\n}\n\n// Store the raw response for debugging\nconst sentimentData = {\n  overall_sentiment: overallSentiment,\n  sentiment_score: sentimentScore,\n  emotional_tone: emotionalTone,\n  energy_level: energyLevel,\n  raw_response: rawResponse,\n  parsing_method: parsingMethod\n};\n\nreturn {\n  json: {\n    noteId: noteId,\n    concepts: concepts,\n    conceptConfidence: conceptConfidence,\n    primaryTheme: primaryTheme,\n    secondaryThemes: secondaryThemes,\n    themeConfidence: themeConfidence,\n    overallSentiment: overallSentiment,\n    sentimentScore: sentimentScore,\n    emotionalTone: emotionalTone,\n    energyLevel: energyLevel,\n    sentimentData: sentimentData,\n    processingModel: 'apple_intelligence'\n  }\n};"
      },
      "id": "function-parse-response",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 700]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteId = $json.noteId;\nconst concepts = $json.concepts;\nconst conceptConfidence = $json.conceptConfidence;\nconst primaryTheme = $json.primaryTheme;\nconst secondaryThemes = $json.secondaryThemes;\nconst themeConfidence = $json.themeConfidence;\nconst overallSentiment = $json.overallSentiment;\nconst sentimentScore = $json.sentimentScore;\nconst emotionalTone = $json.emotionalTone;\nconst energyLevel = $json.energyLevel;\nconst sentimentData = $json.sentimentData;\nconst processingModel = $json.processingModel;\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  // Verify note is in processing_apple state\n  const checkQuery = `SELECT id, status_apple FROM raw_notes WHERE id = ?`;\n  const noteCheck = db.prepare(checkQuery).get(noteId);\n  \n  if (!noteCheck) {\n    db.close();\n    throw new Error(`Note ${noteId} not found`);\n  }\n  \n  if (noteCheck.status_apple !== 'processing_apple') {\n    db.close();\n    throw new Error(`Note ${noteId} is not in processing_apple state (current: ${noteCheck.status_apple})`);\n  }\n  \n  // Insert processed results\n  const insertQuery = `INSERT INTO processed_notes_apple (\n    raw_note_id, concepts, concept_confidence,\n    primary_theme, secondary_themes, theme_confidence,\n    sentiment_analyzed, sentiment_data, overall_sentiment,\n    sentiment_score, emotional_tone, energy_level,\n    sentiment_analyzed_at, processed_at, processing_model\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\n  \n  const result = db.prepare(insertQuery).run(\n    noteId,\n    JSON.stringify(concepts),\n    JSON.stringify(conceptConfidence),\n    primaryTheme,\n    JSON.stringify(secondaryThemes),\n    themeConfidence,\n    1, // sentiment_analyzed\n    JSON.stringify(sentimentData),\n    overallSentiment,\n    sentimentScore,\n    emotionalTone,\n    energyLevel,\n    new Date().toISOString(),\n    new Date().toISOString(),\n    processingModel\n  );\n  \n  // Update raw_notes status to processed_apple\n  const updateQuery = `UPDATE raw_notes \n                      SET status_apple = 'processed_apple', \n                          processed_at_apple = datetime('now') \n                      WHERE id = ?`;\n  db.prepare(updateQuery).run(noteId);\n  \n  db.close();\n  \n  return [{ \n    json: { \n      success: true,\n      processed_id: result.lastInsertRowid, \n      noteId: noteId,\n      concepts: concepts,\n      primaryTheme: primaryTheme,\n      sentiment: overallSentiment,\n      message: `Note ${noteId} processed successfully with Apple Intelligence`\n    } \n  }];\n  \n} catch (error) {\n  console.error('SQLite Error:', error);\n  \n  // Try to reset status to error_apple on error\n  try {\n    const db = new Database('/selene/data/selene.db');\n    db.prepare(`UPDATE raw_notes SET status_apple = 'error_apple' WHERE id = ?`).run(noteId);\n    db.close();\n  } catch (resetError) {\n    console.error('Failed to reset note status:', resetError);\n  }\n  \n  throw new Error('Database operation failed: ' + error.message);\n}"
      },
      "id": "function-save-to-db",
      "name": "Save to Database",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 700]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "respond-save-success",
      "name": "Respond: Save Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [850, 700]
    }
  ],
  "connections": {
    "Webhook: Get Pending Note": {
      "main": [
        [
          {
            "node": "Get Note and Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Note and Lock": {
      "main": [
        [
          {
            "node": "Check if Note Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Note Found": {
      "main": [
        [
          {
            "node": "Build No Pending Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Combined Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build No Pending Response": {
      "main": [
        [
          {
            "node": "Respond: No Pending",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Combined Prompt": {
      "main": [
        [
          {
            "node": "Respond with Note and Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook: Save Processed Note": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Save to Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Database": {
      "main": [
        [
          {
            "node": "Respond: Save Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "executionTimeout": 300,
    "timezone": "America/Los_Angeles"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}
