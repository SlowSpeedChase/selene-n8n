{
  "name": "03-Pattern-Detection-Enhanced | Selene",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 6 * * *"
            }
          ]
        }
      },
      "id": "cron-daily",
      "name": "Daily at 6am",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "pattern-analysis",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 500],
      "webhookId": "pattern-analysis-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Merge both triggers into single flow\nreturn $input.all();"
      },
      "id": "merge-triggers",
      "name": "Merge Triggers",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 400]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  // Get all concepts from processed notes\n  const query = `\n    SELECT \n      id,\n      raw_note_id,\n      concepts,\n      primary_theme,\n      processed_at\n    FROM processed_notes\n    WHERE concepts IS NOT NULL\n    ORDER BY processed_at DESC\n  `;\n  \n  const stmt = db.prepare(query);\n  const results = stmt.all();\n  \n  db.close();\n  \n  // Parse concepts and flatten\n  const conceptData = [];\n  results.forEach(row => {\n    try {\n      const concepts = JSON.parse(row.concepts);\n      concepts.forEach(concept => {\n        conceptData.push({\n          noteId: row.id,\n          rawNoteId: row.raw_note_id,\n          concept: concept.toLowerCase().trim(),\n          theme: row.primary_theme,\n          processedAt: row.processed_at\n        });\n      });\n    } catch (e) {\n      console.error('Error parsing concepts for note', row.id);\n    }\n  });\n  \n  return [{ json: { conceptData, totalNotes: results.length } }];\n  \n} catch (error) {\n  console.error('SQLite Query Error:', error);\n  throw new Error('Database query failed: ' + error.message);\n}"
      },
      "id": "get-concepts",
      "name": "Get All Concepts",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 400]
    },
    {
      "parameters": {
        "functionCode": "const data = $json.conceptData;\n\nif (!data || data.length < 5) {\n  return [];\n}\n\n// Count concept frequencies\nconst conceptFreq = {};\ndata.forEach(item => {\n  const concept = item.concept;\n  if (!conceptFreq[concept]) {\n    conceptFreq[concept] = {\n      count: 0,\n      notes: new Set(),\n      themes: new Set(),\n      firstSeen: item.processedAt,\n      lastSeen: item.processedAt\n    };\n  }\n  conceptFreq[concept].count++;\n  conceptFreq[concept].notes.add(item.noteId);\n  conceptFreq[concept].themes.add(item.theme);\n  \n  if (item.processedAt < conceptFreq[concept].firstSeen) {\n    conceptFreq[concept].firstSeen = item.processedAt;\n  }\n  if (item.processedAt > conceptFreq[concept].lastSeen) {\n    conceptFreq[concept].lastSeen = item.processedAt;\n  }\n});\n\n// Find co-occurring concepts (concepts that appear together in notes)\nconst coOccurrence = {};\nconst notesByNote = {};\ndata.forEach(item => {\n  if (!notesByNote[item.noteId]) {\n    notesByNote[item.noteId] = [];\n  }\n  notesByNote[item.noteId].push(item.concept);\n});\n\nObject.values(notesByNote).forEach(noteConcepts => {\n  if (noteConcepts.length < 2) return;\n  \n  for (let i = 0; i < noteConcepts.length; i++) {\n    for (let j = i + 1; j < noteConcepts.length; j++) {\n      const pair = [noteConcepts[i], noteConcepts[j]].sort().join('|');\n      if (!coOccurrence[pair]) {\n        coOccurrence[pair] = 0;\n      }\n      coOccurrence[pair]++;\n    }\n  }\n});\n\n// Identify concept clusters (concepts that frequently co-occur)\nconst patterns = [];\nconst minCoOccurrence = 2; // Minimum times concepts must co-occur\n\nObject.entries(coOccurrence)\n  .filter(([_, count]) => count >= minCoOccurrence)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 10) // Top 10 clusters\n  .forEach(([pair, count]) => {\n    const [concept1, concept2] = pair.split('|');\n    const freq1 = conceptFreq[concept1];\n    const freq2 = conceptFreq[concept2];\n    \n    const totalAppearances = Math.min(freq1.count, freq2.count);\n    const strength = count / totalAppearances;\n    \n    const commonThemes = Array.from(freq1.themes).filter(t => freq2.themes.has(t));\n    \n    patterns.push({\n      patternType: 'concept_cluster',\n      patternName: `Concept Cluster: ${concept1} + ${concept2}`,\n      description: `The concepts '${concept1}' and '${concept2}' frequently appear together (${count} times). This suggests a strong connection in your thinking.`,\n      confidence: Math.min(0.9, strength * 0.7 + 0.2),\n      dataPoints: count,\n      timeRangeStart: Math.min(freq1.firstSeen, freq2.firstSeen),\n      timeRangeEnd: Math.max(freq1.lastSeen, freq2.lastSeen),\n      patternData: {\n        concept1: concept1,\n        concept2: concept2,\n        coOccurrenceCount: count,\n        concept1Frequency: freq1.count,\n        concept2Frequency: freq2.count,\n        connectionStrength: strength,\n        commonThemes: commonThemes,\n        notesInvolved: count\n      },\n      insights: `These concepts form a cluster appearing in ${count} notes together${commonThemes.length > 0 ? `, primarily in ${commonThemes.join(', ')} contexts` : ''}. This indicates a consistent pattern in how you connect these ideas.`,\n      discoveredAt: new Date().toISOString(),\n      isActive: true\n    });\n  });\n\n// Also identify dominant concepts (high frequency)\nconst dominantConcepts = Object.entries(conceptFreq)\n  .filter(([_, freq]) => freq.count >= 3)\n  .sort((a, b) => b[1].count - a[1].count)\n  .slice(0, 5)\n  .forEach(([concept, freq]) => {\n    const displayConcept = concept.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n    const noteCount = freq.notes.size;\n    const themeSpread = freq.themes.size;\n    \n    patterns.push({\n      patternType: 'dominant_concept',\n      patternName: `Dominant Concept: ${displayConcept}`,\n      description: `'${displayConcept}' appears frequently across ${noteCount} notes, spanning ${themeSpread} different theme${themeSpread > 1 ? 's' : ''}.`,\n      confidence: Math.min(0.85, (freq.count / $json.totalNotes) * 2),\n      dataPoints: freq.count,\n      timeRangeStart: freq.firstSeen,\n      timeRangeEnd: freq.lastSeen,\n      patternData: {\n        concept: concept,\n        displayName: displayConcept,\n        totalMentions: freq.count,\n        uniqueNotes: noteCount,\n        themeSpread: themeSpread,\n        themes: Array.from(freq.themes)\n      },\n      insights: `This is a core concept in your recent thinking, appearing across multiple themes. Consider exploring this concept more deeply or creating dedicated documentation around it.`,\n      discoveredAt: new Date().toISOString(),\n      isActive: true\n    });\n  });\n\nreturn patterns.map(p => ({ json: p }));"
      },
      "id": "analyze-concepts",
      "name": "Analyze Concept Clusters",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 400]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  const query = `\n    SELECT \n      id,\n      raw_note_id,\n      overall_sentiment,\n      sentiment_score,\n      energy_level,\n      emotional_tone,\n      sentiment_analyzed_at\n    FROM processed_notes\n    WHERE sentiment_analyzed = 1\n    ORDER BY sentiment_analyzed_at DESC\n  `;\n  \n  const stmt = db.prepare(query);\n  const results = stmt.all();\n  \n  db.close();\n  \n  return [{ json: { sentimentData: results, totalNotes: results.length } }];\n  \n} catch (error) {\n  console.error('SQLite Query Error:', error);\n  throw new Error('Database query failed: ' + error.message);\n}"
      },
      "id": "get-sentiment",
      "name": "Get Sentiment Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 600]
    },
    {
      "parameters": {
        "functionCode": "const data = $json.sentimentData;\n\nif (!data || data.length < 3) {\n  return [];\n}\n\nconst patterns = [];\n\n// Analyze energy level distribution\nconst energyLevels = {};\ndata.forEach(item => {\n  const level = item.energy_level;\n  if (!energyLevels[level]) {\n    energyLevels[level] = 0;\n  }\n  energyLevels[level]++;\n});\n\nconst totalNotes = data.length;\nObject.entries(energyLevels).forEach(([level, count]) => {\n  const percentage = (count / totalNotes) * 100;\n  \n  if (percentage >= 30) { // Dominant energy pattern\n    const displayLevel = level.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n    \n    patterns.push({\n      patternType: 'energy_pattern',\n      patternName: `Energy Pattern: ${displayLevel}`,\n      description: `${percentage.toFixed(1)}% of your recent notes show ${displayLevel} energy levels (${count} of ${totalNotes} notes).`,\n      confidence: Math.min(0.85, percentage / 100),\n      dataPoints: count,\n      timeRangeStart: data[data.length - 1].sentiment_analyzed_at,\n      timeRangeEnd: data[0].sentiment_analyzed_at,\n      patternData: {\n        energyLevel: level,\n        displayLevel: displayLevel,\n        occurrences: count,\n        percentage: percentage,\n        totalNotes: totalNotes\n      },\n      insights: percentage >= 50 \n        ? `This dominant ${displayLevel} energy pattern suggests consistent ${level === 'high' ? 'engagement and motivation' : level === 'medium' ? 'steady productivity' : 'potential need for rest or reduced cognitive load'}. Consider ${level === 'high' ? 'leveraging this energy for challenging tasks' : level === 'medium' ? 'maintaining sustainable practices' : 'adjusting workload or incorporating more breaks'}.`\n        : `A notable ${displayLevel} energy pattern is emerging. Monitor whether this aligns with your goals and well-being.`,\n      discoveredAt: new Date().toISOString(),\n      isActive: true\n    });\n  }\n});\n\n// Analyze sentiment trends\nconst sentiments = {};\ndata.forEach(item => {\n  const sentiment = item.overall_sentiment;\n  if (!sentiments[sentiment]) {\n    sentiments[sentiment] = {\n      count: 0,\n      scores: []\n    };\n  }\n  sentiments[sentiment].count++;\n  if (item.sentiment_score !== null) {\n    sentiments[sentiment].scores.push(item.sentiment_score);\n  }\n});\n\nObject.entries(sentiments).forEach(([sentiment, info]) => {\n  const percentage = (info.count / totalNotes) * 100;\n  \n  if (percentage >= 25) {\n    const avgScore = info.scores.length > 0\n      ? info.scores.reduce((a, b) => a + b, 0) / info.scores.length\n      : 0;\n    \n    const displaySentiment = sentiment.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n    \n    patterns.push({\n      patternType: 'sentiment_pattern',\n      patternName: `Sentiment Pattern: ${displaySentiment}`,\n      description: `${percentage.toFixed(1)}% of your notes reflect ${displaySentiment} sentiment${avgScore > 0 ? ` (avg score: ${avgScore.toFixed(2)})` : ''}.`,\n      confidence: Math.min(0.80, percentage / 100),\n      dataPoints: info.count,\n      timeRangeStart: data[data.length - 1].sentiment_analyzed_at,\n      timeRangeEnd: data[0].sentiment_analyzed_at,\n      patternData: {\n        sentiment: sentiment,\n        displaySentiment: displaySentiment,\n        occurrences: info.count,\n        percentage: percentage,\n        averageScore: avgScore,\n        totalNotes: totalNotes\n      },\n      insights: sentiment === 'positive'\n        ? `Strong positive sentiment suggests good mental state and engagement. Continue practices that support this.`\n        : sentiment === 'negative'\n        ? `Notable negative sentiment pattern detected. Consider whether external stressors need addressing or if self-care practices need strengthening.`\n        : `Neutral sentiment suggests balanced perspective. This can be healthy, though watch for emotional suppression.`,\n      discoveredAt: new Date().toISOString(),\n      isActive: true\n    });\n  }\n});\n\n// Analyze emotional tone patterns\nconst tones = {};\ndata.forEach(item => {\n  const tone = item.emotional_tone;\n  if (tone && tone !== 'null') {\n    if (!tones[tone]) {\n      tones[tone] = 0;\n    }\n    tones[tone]++;\n  }\n});\n\nconst topTone = Object.entries(tones)\n  .sort((a, b) => b[1] - a[1])[0];\n\nif (topTone) {\n  const [tone, count] = topTone;\n  const percentage = (count / totalNotes) * 100;\n  \n  if (percentage >= 20) {\n    const displayTone = tone.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n    \n    patterns.push({\n      patternType: 'emotional_tone_pattern',\n      patternName: `Emotional Tone: ${displayTone}`,\n      description: `Your dominant emotional tone is ${displayTone}, appearing in ${percentage.toFixed(1)}% of notes.`,\n      confidence: Math.min(0.75, percentage / 100),\n      dataPoints: count,\n      timeRangeStart: data[data.length - 1].sentiment_analyzed_at,\n      timeRangeEnd: data[0].sentiment_analyzed_at,\n      patternData: {\n        emotionalTone: tone,\n        displayTone: displayTone,\n        occurrences: count,\n        percentage: percentage,\n        totalNotes: totalNotes\n      },\n      insights: `This emotional pattern provides insight into your current state. ${displayTone} tone suggests specific mindset characteristics worth being aware of.`,\n      discoveredAt: new Date().toISOString(),\n      isActive: true\n    });\n  }\n}\n\nreturn patterns.map(p => ({ json: p }));"
      },
      "id": "analyze-sentiment",
      "name": "Analyze Sentiment Patterns",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 600]
    },
    {
      "parameters": {
        "functionCode": "// Collect all patterns from different analysis paths\nconst allPatterns = $input.all();\nreturn allPatterns;"
      },
      "id": "merge-patterns",
      "name": "Merge All Patterns",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  const insertQuery = `INSERT INTO detected_patterns (\n    pattern_type, pattern_name, description,\n    confidence, data_points, pattern_data,\n    time_range_start, time_range_end,\n    insights, discovered_at, is_active\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\n  \n  const stmt = db.prepare(insertQuery);\n  const result = stmt.run(\n    $json.patternType,\n    $json.patternName,\n    $json.description,\n    $json.confidence,\n    $json.dataPoints,\n    JSON.stringify($json.patternData),\n    $json.timeRangeStart,\n    $json.timeRangeEnd,\n    $json.insights,\n    $json.discoveredAt,\n    $json.isActive ? 1 : 0\n  );\n  \n  db.close();\n  \n  return { json: { pattern_id: result.lastInsertRowid, ...($json) } };\n  \n} catch (error) {\n  console.error('SQLite Insert Error:', error);\n  throw new Error('Database insert failed: ' + error.message);\n}"
      },
      "id": "store-pattern",
      "name": "Store Pattern",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 500]
    },
    {
      "parameters": {
        "functionCode": "const allPatterns = $input.all();\n\n// Group patterns by type\nconst patternsByType = {};\nallPatterns.forEach(p => {\n  const type = p.json.patternType;\n  if (!patternsByType[type]) {\n    patternsByType[type] = [];\n  }\n  patternsByType[type].push(p.json);\n});\n\n// Group by confidence level\nconst highConfidence = allPatterns.filter(p => p.json.confidence >= 0.7);\nconst mediumConfidence = allPatterns.filter(p => p.json.confidence >= 0.4 && p.json.confidence < 0.7);\nconst lowConfidence = allPatterns.filter(p => p.json.confidence < 0.4);\n\n// Generate key insights\nconst keyInsights = [];\n\nif (allPatterns.length === 0) {\n  keyInsights.push(`â„¹ï¸ No significant patterns detected yet. Continue capturing notes to build pattern history.`);\n} else {\n  keyInsights.push(`ðŸŽ¯ Found ${allPatterns.length} pattern${allPatterns.length > 1 ? 's' : ''} across your notes.`);\n  \n  if (highConfidence.length > 0) {\n    keyInsights.push(`âœ¨ ${highConfidence.length} high-confidence pattern${highConfidence.length > 1 ? 's' : ''} detected with strong evidence.`);\n  }\n  \n  // Pattern type summary\n  Object.entries(patternsByType).forEach(([type, patterns]) => {\n    const displayType = type.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n    keyInsights.push(`ðŸ“Š ${patterns.length} ${displayType} pattern${patterns.length > 1 ? 's' : ''} identified.`);\n  });\n}\n\n// Generate recommendations\nconst recommendations = [];\n\nif (patternsByType['concept_cluster']) {\n  const topCluster = patternsByType['concept_cluster']\n    .sort((a, b) => b.confidence - a.confidence)[0];\n  if (topCluster) {\n    recommendations.push(`ðŸ’¡ Strong concept connection detected: ${topCluster.patternData.concept1} + ${topCluster.patternData.concept2}. Consider creating a dedicated note exploring this relationship.`);\n  }\n}\n\nif (patternsByType['energy_pattern']) {\n  const energyPattern = patternsByType['energy_pattern'][0];\n  if (energyPattern && energyPattern.patternData.energyLevel === 'low') {\n    recommendations.push(`ðŸ”‹ Low energy pattern detected. Consider scheduling lighter tasks or incorporating more breaks.`);\n  } else if (energyPattern && energyPattern.patternData.energyLevel === 'high') {\n    recommendations.push(`âš¡ High energy pattern! Great time to tackle challenging or creative tasks.`);\n  }\n}\n\nif (patternsByType['dominant_concept'] && patternsByType['dominant_concept'].length >= 2) {\n  const topConcepts = patternsByType['dominant_concept']\n    .sort((a, b) => b.confidence - a.confidence)\n    .slice(0, 2)\n    .map(p => p.patternData.displayName);\n  recommendations.push(`ðŸ“š Core concepts emerging: ${topConcepts.join(', ')}. These could form the foundation for deeper exploration or documentation.`);\n}\n\nif (highConfidence.length >= 3) {\n  recommendations.push(`ðŸ“ˆ Strong patterns detected across multiple dimensions. Your note-taking is revealing clear trends in your thinking and focus areas.`);\n}\n\nif (allPatterns.length === 0) {\n  recommendations.push(`ðŸ“ Keep capturing notes! Pattern detection becomes more powerful with more data.`);\n}\n\n// Build summary report\nconst report = {\n  reportId: `pattern_report_${Date.now()}`,\n  generatedAt: new Date().toISOString(),\n  timeRangeStart: allPatterns.length > 0 \n    ? allPatterns.reduce((min, p) => p.json.timeRangeStart < min ? p.json.timeRangeStart : min, allPatterns[0].json.timeRangeStart)\n    : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\n  timeRangeEnd: allPatterns.length > 0\n    ? allPatterns.reduce((max, p) => p.json.timeRangeEnd > max ? p.json.timeRangeEnd : max, allPatterns[0].json.timeRangeEnd)\n    : new Date().toISOString(),\n  totalPatternsDetected: allPatterns.length,\n  highConfidencePatterns: highConfidence.length,\n  mediumConfidencePatterns: mediumConfidence.length,\n  lowConfidencePatterns: lowConfidence.length,\n  patternTypes: Object.keys(patternsByType),\n  patternTypeCount: Object.entries(patternsByType).map(([type, patterns]) => ({\n    type: type,\n    count: patterns.length\n  })),\n  keyInsights: keyInsights,\n  recommendations: recommendations,\n  patterns: allPatterns.map(p => ({\n    name: p.json.patternName,\n    type: p.json.patternType,\n    confidence: p.json.confidence,\n    dataPoints: p.json.dataPoints,\n    description: p.json.description\n  }))\n};\n\nreturn {\n  json: report\n};"
      },
      "id": "generate-report",
      "name": "Generate Insights Report",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1450, 500]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  const insertQuery = `INSERT INTO pattern_reports (\n    report_id, generated_at, time_range_start, time_range_end,\n    total_patterns, high_confidence_count, medium_confidence_count, low_confidence_count,\n    rising_trends_count, falling_trends_count,\n    key_insights, recommendations, report_data\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\n  \n  const stmt = db.prepare(insertQuery);\n  stmt.run(\n    $json.reportId,\n    $json.generatedAt,\n    $json.timeRangeStart,\n    $json.timeRangeEnd,\n    $json.totalPatternsDetected,\n    $json.highConfidencePatterns,\n    $json.mediumConfidencePatterns,\n    $json.lowConfidencePatterns,\n    0, // rising_trends (calculated from pattern data)\n    0, // falling_trends (calculated from pattern data)\n    JSON.stringify($json.keyInsights),\n    JSON.stringify($json.recommendations),\n    JSON.stringify($json.patterns)\n  );\n  \n  db.close();\n  \n  return {\n    json: {\n      success: true,\n      reportId: $json.reportId,\n      patternsDetected: $json.totalPatternsDetected,\n      message: `Pattern analysis complete: ${$json.totalPatternsDetected} patterns detected`,\n      keyInsights: $json.keyInsights,\n      recommendations: $json.recommendations\n    }\n  };\n  \n} catch (error) {\n  console.error('SQLite Insert Error:', error);\n  throw new Error('Database insert failed: ' + error.message);\n}"
      },
      "id": "store-report",
      "name": "Store Report",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "webhook-response",
      "name": "Return Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1850, 500]
    }
  ],
  "connections": {
    "Daily at 6am": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Merge Triggers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Triggers": {
      "main": [
        [
          {
            "node": "Get All Concepts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Sentiment Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Concepts": {
      "main": [
        [
          {
            "node": "Analyze Concept Clusters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Concept Clusters": {
      "main": [
        [
          {
            "node": "Merge All Patterns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Sentiment Data": {
      "main": [
        [
          {
            "node": "Analyze Sentiment Patterns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Sentiment Patterns": {
      "main": [
        [
          {
            "node": "Merge All Patterns",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Patterns": {
      "main": [
        [
          {
            "node": "Store Pattern",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Pattern": {
      "main": [
        [
          {
            "node": "Generate Insights Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Insights Report": {
      "main": [
        [
          {
            "node": "Store Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Report": {
      "main": [
        [
          {
            "node": "Return Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}
