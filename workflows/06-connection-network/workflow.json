{
  "name": "06-Connection-Network | Selene",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 */6 * * *"
            }
          ]
        }
      },
      "id": "cron-connections",
      "name": "Every 6 Hours",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/network-analysis",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-network",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 450],
      "webhookId": "network-analysis-webhook"
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  const query = `SELECT\n    pn.id as processed_id,\n    pn.raw_note_id,\n    rn.title,\n    rn.created_at,\n    pn.concepts,\n    pn.primary_theme,\n    pn.secondary_themes\n  FROM processed_notes pn\n  JOIN raw_notes rn ON pn.raw_note_id = rn.id\n  WHERE rn.status = 'processed'\n  ORDER BY rn.created_at DESC\n  LIMIT 100`;\n  \n  const stmt = db.prepare(query);\n  const results = stmt.all();\n  \n  db.close();\n  \n  return results.map(row => ({ json: row }));\n  \n} catch (error) {\n  console.error('SQLite Query Error:', error);\n  throw new Error('Database query failed: ' + error.message);\n}"
      },
      "id": "sqlite-get-all-notes",
      "name": "Get Recent Notes",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "const notes = $input.all();\n\n// Parse all notes and build concept/theme maps\nconst noteData = notes.map(note => {\n  let concepts = [];\n  let secondaryThemes = [];\n  \n  try {\n    concepts = JSON.parse(note.json.concepts || '[]');\n  } catch (e) {}\n  \n  try {\n    secondaryThemes = JSON.parse(note.json.secondary_themes || '[]');\n  } catch (e) {}\n  \n  return {\n    id: note.json.raw_note_id,\n    processedId: note.json.processed_id,\n    title: note.json.title,\n    createdAt: note.json.created_at,\n    concepts: concepts,\n    primaryTheme: note.json.primary_theme,\n    secondaryThemes: secondaryThemes,\n    allThemes: [note.json.primary_theme, ...secondaryThemes]\n  };\n});\n\n// Calculate connections between notes\nconst connections = [];\n\nfor (let i = 0; i < noteData.length; i++) {\n  for (let j = i + 1; j < noteData.length; j++) {\n    const note1 = noteData[i];\n    const note2 = noteData[j];\n    \n    // Skip if same note ID (handles duplicate processed_notes entries)\n    if (note1.id === note2.id) continue;\n    \n    // Calculate concept overlap\n    const sharedConcepts = note1.concepts.filter(c => \n      note2.concepts.includes(c)\n    );\n    const conceptOverlap = sharedConcepts.length;\n    const conceptOverlapScore = conceptOverlap / Math.max(\n      Math.max(note1.concepts.length, note2.concepts.length),\n      1\n    );\n    \n    // Calculate theme overlap\n    const sharedThemes = note1.allThemes.filter(t => \n      note2.allThemes.includes(t)\n    );\n    const themeOverlap = sharedThemes.length;\n    const themeOverlapScore = themeOverlap / Math.max(\n      Math.max(note1.allThemes.length, note2.allThemes.length),\n      1\n    );\n    \n    // Calculate temporal proximity (closer in time = higher score)\n    const date1 = new Date(note1.createdAt);\n    const date2 = new Date(note2.createdAt);\n    const daysDiff = Math.abs(date1 - date2) / (1000 * 60 * 60 * 24);\n    const temporalScore = Math.max(0, 1 - (daysDiff / 30)); // 30-day window\n    \n    // Combined connection strength\n    const connectionStrength = (\n      conceptOverlapScore * 0.5 +\n      themeOverlapScore * 0.3 +\n      temporalScore * 0.2\n    );\n    \n    // Only create connections above threshold\n    if (connectionStrength >= 0.3) {\n      connections.push({\n        sourceNoteId: note1.id,\n        targetNoteId: note2.id,\n        sourceTitle: note1.title,\n        targetTitle: note2.title,\n        connectionStrength: connectionStrength,\n        sharedConcepts: sharedConcepts,\n        sharedThemes: sharedThemes,\n        conceptOverlapScore: conceptOverlapScore,\n        themeOverlapScore: themeOverlapScore,\n        temporalScore: temporalScore,\n        daysBetween: Math.round(daysDiff),\n        connectionType: conceptOverlap > 0 ? 'concept_based' : 'theme_based'\n      });\n    }\n  }\n}\n\n// Sort by connection strength\nconnections.sort((a, b) => b.connectionStrength - a.connectionStrength);\n\n// Limit to top 500 connections\nconst topConnections = connections.slice(0, 500);\n\nreturn {\n  json: {\n    totalNotesAnalyzed: noteData.length,\n    connectionsFound: topConnections.length,\n    connections: topConnections,\n    analyzedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "function-calculate-connections",
      "name": "Calculate Note Connections",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst analysis = $json;\nconst connections = analysis.connections;\nconst analyzedAt = analysis.analyzedAt;\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  const insertQuery = `INSERT OR REPLACE INTO note_connections (\n    source_note_id, target_note_id,\n    connection_strength, connection_type,\n    shared_concepts, shared_themes,\n    concept_overlap_score, theme_overlap_score,\n    temporal_score, days_between,\n    discovered_at, is_active\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;\n  \n  const stmt = db.prepare(insertQuery);\n  \n  // Use a transaction for batch insert\n  const insertMany = db.transaction((conns) => {\n    for (const conn of conns) {\n      stmt.run(\n        conn.sourceNoteId,\n        conn.targetNoteId,\n        conn.connectionStrength,\n        conn.connectionType,\n        JSON.stringify(conn.sharedConcepts),\n        JSON.stringify(conn.sharedThemes),\n        conn.conceptOverlapScore,\n        conn.themeOverlapScore,\n        conn.temporalScore,\n        conn.daysBetween,\n        analyzedAt,\n        1\n      );\n    }\n    return conns.length;\n  });\n  \n  const insertedCount = insertMany(connections);\n  \n  db.close();\n  \n  return {\n    json: {\n      ...analysis,\n      connectionsStored: insertedCount\n    }\n  };\n  \n} catch (error) {\n  console.error('SQLite Batch Insert Error:', error);\n  throw new Error('Database batch insert failed: ' + error.message);\n}"
      },
      "id": "sqlite-store-connections-batch",
      "name": "Store All Connections",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "functionCode": "// Generate network statistics from the analysis data\nconst analysis = $json;\nconst connections = analysis.connections;\n\n// Find most connected notes (hubs)\nconst noteConnectionCounts = {};\nconnections.forEach(conn => {\n  noteConnectionCounts[conn.sourceNoteId] = (noteConnectionCounts[conn.sourceNoteId] || 0) + 1;\n  noteConnectionCounts[conn.targetNoteId] = (noteConnectionCounts[conn.targetNoteId] || 0) + 1;\n});\n\nconst sortedNotes = Object.entries(noteConnectionCounts)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 10);\n\nconst hubs = sortedNotes.map(([noteId, count]) => {\n  const conn = connections.find(c => \n    c.sourceNoteId == noteId || c.targetNoteId == noteId\n  );\n  return {\n    noteId: parseInt(noteId),\n    connectionCount: count,\n    title: conn ? (conn.sourceNoteId == noteId ? conn.sourceTitle : conn.targetTitle) : 'Unknown'\n  };\n});\n\n// Find strongest connections\nconst strongestConnections = [...connections]\n  .sort((a, b) => b.connectionStrength - a.connectionStrength)\n  .slice(0, 10)\n  .map(c => ({\n    sourceTitle: c.sourceTitle,\n    targetTitle: c.targetTitle,\n    strength: c.connectionStrength,\n    sharedConcepts: c.sharedConcepts.length,\n    type: c.connectionType\n  }));\n\n// Calculate average connection strength\nconst avgStrength = connections.length > 0 \n  ? connections.reduce((sum, c) => sum + c.connectionStrength, 0) / connections.length \n  : 0;\n\n// Count connection types\nconst conceptBased = connections.filter(c => c.connectionType === 'concept_based').length;\nconst themeBased = connections.filter(c => c.connectionType === 'theme_based').length;\n\nreturn {\n  json: {\n    networkStats: {\n      totalNotes: analysis.totalNotesAnalyzed,\n      totalConnections: analysis.connectionsFound,\n      connectionsStored: analysis.connectionsStored,\n      averageConnectionStrength: avgStrength,\n      conceptBasedConnections: conceptBased,\n      themeBasedConnections: themeBased,\n      topHubs: hubs,\n      strongestConnections: strongestConnections,\n      analyzedAt: analysis.analyzedAt\n    }\n  }\n};"
      },
      "id": "function-network-stats",
      "name": "Generate Network Statistics",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  const analysisId = 'network_' + Date.now();\n  \n  const insertQuery = `INSERT INTO network_analysis_history (\n    analysis_id, total_notes, total_connections,\n    avg_connection_strength, concept_based_count, theme_based_count,\n    network_stats, analyzed_at\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;\n  \n  const stmt = db.prepare(insertQuery);\n  stmt.run(\n    analysisId,\n    $json.networkStats.totalNotes,\n    $json.networkStats.totalConnections,\n    $json.networkStats.averageConnectionStrength,\n    $json.networkStats.conceptBasedConnections,\n    $json.networkStats.themeBasedConnections,\n    JSON.stringify($json.networkStats),\n    $json.networkStats.analyzedAt\n  );\n  \n  db.close();\n  \n  return {\n    json: {\n      success: true,\n      analysisId: analysisId,\n      totalNotes: $json.networkStats.totalNotes,\n      totalConnections: $json.networkStats.totalConnections,\n      connectionsStored: $json.networkStats.connectionsStored,\n      avgStrength: $json.networkStats.averageConnectionStrength,\n      message: 'Network analysis completed and stored successfully'\n    }\n  };\n  \n} catch (error) {\n  console.error('SQLite Insert Error:', error);\n  throw new Error('Database insert failed: ' + error.message);\n}"
      },
      "id": "sqlite-store-network-stats",
      "name": "Store Network Statistics",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 300]
    }
  ],
  "connections": {
    "Every 6 Hours": {
      "main": [
        [
          {
            "node": "Get Recent Notes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Get Recent Notes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Recent Notes": {
      "main": [
        [
          {
            "node": "Calculate Note Connections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Note Connections": {
      "main": [
        [
          {
            "node": "Store All Connections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store All Connections": {
      "main": [
        [
          {
            "node": "Generate Network Statistics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Network Statistics": {
      "main": [
        [
          {
            "node": "Store Network Statistics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    },
    {
      "name": "Advanced",
      "id": "advanced-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}
