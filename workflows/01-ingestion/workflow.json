{
  "name": "01-Note-Ingestion | Selene",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/drafts",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-receive",
      "name": "Webhook: Receive from Drafts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        250,
        300
      ],
      "webhookId": "selene-drafts-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Parse incoming note from Drafts app or other sources\nconst body = $input.item.json.body || $input.item.json;\nconst query = $input.item.json.query || {};\n\n// Support multiple input formats\nconst title = body.title || query.title || 'Untitled Note';\nconst content = body.content || query.content || body.text || '';\nconst timestamp = body.created_at || body.timestamp || query.timestamp || new Date().toISOString();\nconst sourceType = body.source_type || query.source_type || 'drafts';\nconst sourceUuid = body.source_uuid || query.source_uuid || null;  // UUID for draft tracking\nconst testRun = body.test_run || query.test_run || null;\n\n// Validate required fields\nif (!content || content.trim().length === 0) {\n  throw new Error('Content is required and cannot be empty');\n}\n\n// Generate content hash for duplicate detection (simple hash function)\n// Using a FNV-1a hash algorithm that works without crypto module\nfunction simpleHash(str) {\n  let hash = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    hash ^= str.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (hash >>> 0).toString(16);\n}\n\nconst contentHash = simpleHash(content.trim());\n\n// Calculate metadata\nconst words = content.trim().split(/\\s+/).filter(w => w.length > 0);\nconst wordCount = words.length;\nconst characterCount = content.length;\n\n// Extract tags if present (format: #tag)\nconst tagMatches = content.match(/#(\\w+)/g) || [];\nconst tags = tagMatches.map(t => t.substring(1));\n\nreturn {\n  json: {\n    title: title.trim(),\n    content: content.trim(),\n    contentHash: contentHash,\n    timestamp: timestamp,\n    wordCount: wordCount,\n    characterCount: characterCount,\n    tags: tags,\n    sourceType: sourceType,\n    sourceUuid: sourceUuid,\n    testRun: testRun,\n    status: 'pending'\n  }\n};"
      },
      "id": "function-parse",
      "name": "Parse Note Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $json;\n\ntry {\n  const db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  // UUID-First Duplicate Detection Strategy\n  let result = null;\n  let duplicateType = null;\n  \n  if (noteData.sourceUuid) {\n    // Step 1: Check if UUID exists\n    const uuidQuery = `SELECT id, title, content_hash, created_at, source_uuid FROM raw_notes WHERE source_uuid = ? LIMIT 1`;\n    const uuidStmt = db.prepare(uuidQuery);\n    const uuidMatch = uuidStmt.get(noteData.sourceUuid);\n    \n    if (uuidMatch) {\n      // UUID exists - check if content changed\n      if (uuidMatch.content_hash === noteData.contentHash) {\n        // Exact duplicate (same UUID, same content)\n        result = uuidMatch;\n        duplicateType = 'uuid_exact_duplicate';\n      } else {\n        // Edit detected (same UUID, different content)\n        result = uuidMatch;\n        duplicateType = 'uuid_edit_detected';\n      }\n    } else {\n      // UUID not found - check content_hash for accidental duplicates\n      const hashQuery = `SELECT id, title, content_hash, created_at, source_uuid FROM raw_notes WHERE content_hash = ? LIMIT 1`;\n      const hashStmt = db.prepare(hashQuery);\n      const hashMatch = hashStmt.get(noteData.contentHash);\n      \n      if (hashMatch) {\n        // Same content exists with different UUID/source\n        result = hashMatch;\n        duplicateType = 'content_duplicate';\n      } else {\n        // New note\n        result = null;\n        duplicateType = 'new_note';\n      }\n    }\n  } else {\n    // No UUID provided - fall back to content_hash only (backward compatible)\n    const hashQuery = `SELECT id, title, content_hash, created_at, source_uuid FROM raw_notes WHERE content_hash = ? LIMIT 1`;\n    const hashStmt = db.prepare(hashQuery);\n    const hashMatch = hashStmt.get(noteData.contentHash);\n    \n    if (hashMatch) {\n      result = hashMatch;\n      duplicateType = 'content_duplicate';\n    } else {\n      result = null;\n      duplicateType = 'new_note';\n    }\n  }\n  \n  db.close();\n  \n  return { \n    json: result ? { \n      ...result, \n      duplicateType: duplicateType \n    } : { \n      id: null, \n      duplicateType: duplicateType \n    } \n  };\n  \n} catch (error) {\n  console.error('SQLite Duplicate Check Error:', error);\n  // If database doesn't exist or has errors, treat as new note\n  return { json: { id: null, duplicateType: 'new_note' } };\n}"
      },
      "id": "sqlite-check-duplicate",
      "name": "Check for Duplicate",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        650,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.duplicateType === 'new_note' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "switch-is-duplicate",
      "name": "Is New Note?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        850,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.duplicateType === 'uuid_edit_detected' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "switch-is-edit",
      "name": "Is Edit?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1050,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $('Parse Note Data').item.json;\nconst existingNote = $('Check for Duplicate').item.json;\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n\n  // Update existing note with new content\n  // Reset status to 'pending' for re-processing\n  // Preserve original created_at\n  const updateQuery = `UPDATE raw_notes SET\n    content = ?,\n    content_hash = ?,\n    title = ?,\n    word_count = ?,\n    character_count = ?,\n    tags = ?,\n    imported_at = ?,\n    status = 'pending',\n    status_apple = 'pending_apple'\n  WHERE id = ?`;\n\n  const stmt = db.prepare(updateQuery);\n  const result = stmt.run(\n    noteData.content,\n    noteData.contentHash,\n    noteData.title,\n    noteData.wordCount,\n    noteData.characterCount,\n    JSON.stringify(noteData.tags),\n    noteData.timestamp,\n    existingNote.id\n  );\n\n  db.close();\n\n  return {\n    json: {\n      note_id: existingNote.id,\n      title: noteData.title,\n      wordCount: noteData.wordCount,\n      contentHash: noteData.contentHash,\n      sourceType: noteData.sourceType,\n      sourceUuid: noteData.sourceUuid,\n      testRun: noteData.testRun,\n      action: 'updated',\n      previousHash: existingNote.content_hash\n    }\n  };\n\n} catch (error) {\n  console.error('SQLite Update Error:', error);\n  throw new Error(`Failed to update note: ${error.message}`);\n}"
      },
      "id": "sqlite-update",
      "name": "Update Existing Note",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        350
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $('Parse Note Data').item.json;\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n\n  // Insert the note into raw_notes table\n  // Sets both status='pending' (for Ollama) and status_apple='pending_apple' (for Apple Intelligence)\n  const insertQuery = `INSERT INTO raw_notes (\n    title, content, content_hash, source_type, source_uuid,\n    word_count, character_count, tags,\n    created_at, imported_at, status, status_apple, test_run\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'pending_apple', ?)`;\n\n  const stmt = db.prepare(insertQuery);\n  const result = stmt.run(\n    noteData.title,\n    noteData.content,\n    noteData.contentHash,\n    noteData.sourceType,\n    noteData.sourceUuid,\n    noteData.wordCount,\n    noteData.characterCount,\n    JSON.stringify(noteData.tags),\n    noteData.timestamp,\n    noteData.timestamp,\n    noteData.testRun\n  );\n\n  db.close();\n\n  return {\n    json: {\n      note_id: result.lastInsertRowid,\n      title: noteData.title,\n      wordCount: noteData.wordCount,\n      contentHash: noteData.contentHash,\n      sourceType: noteData.sourceType,\n      sourceUuid: noteData.sourceUuid,\n      testRun: noteData.testRun\n    }\n  };\n\n} catch (error) {\n  console.error('SQLite Insert Error:', error);\n  throw new Error(`Failed to insert note: ${error.message}`);\n}"
      },
      "id": "sqlite-insert",
      "name": "Insert Note",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1050,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "const updateResult = $json;\n\nreturn {\n  json: {\n    success: true,\n    action: 'updated',\n    message: 'Note content updated - edit detected',\n    noteId: updateResult.note_id,\n    title: updateResult.title,\n    wordCount: updateResult.wordCount,\n    contentHash: updateResult.contentHash,\n    previousHash: updateResult.previousHash,\n    sourceType: updateResult.sourceType,\n    sourceUuid: updateResult.sourceUuid,\n    status: 'pending'\n  }\n};"
      },
      "id": "function-update",
      "name": "Build Update Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1450,
        350
      ]
    },
    {
      "parameters": {
        "functionCode": "const insertResult = $json;\n\nreturn {\n  json: {\n    success: true,\n    action: 'stored',\n    message: 'Note successfully ingested into raw_notes table',\n    noteId: insertResult.note_id,\n    title: insertResult.title,\n    wordCount: insertResult.wordCount,\n    contentHash: insertResult.contentHash,\n    sourceType: insertResult.sourceType,\n    status: 'pending'\n  }\n};"
      },
      "id": "function-success",
      "name": "Build Success Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/api/process-note",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "noteId",
              "value": "={{ $json.noteId }}"
            }
          ]
        },
        "options": {
          "timeout": 120000,
          "redirect": {
            "redirect": {}
          }
        }
      },
      "id": "http-trigger-processing",
      "name": "Trigger LLM Processing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1450,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "const ingestionData = $('Build Success Response').item.json;\nconst processingData = $json;\n\nreturn {\n  json: {\n    success: true,\n    action: 'stored_and_processed',\n    message: 'Note ingested and LLM processing triggered successfully',\n    noteId: ingestionData.noteId,\n    title: ingestionData.title,\n    wordCount: ingestionData.wordCount,\n    processing: {\n      status: processingData.success ? 'processing' : 'queued',\n      conceptsExtracted: processingData.conceptsExtracted || 0,\n      primaryTheme: processingData.primaryTheme || null,\n      sentiment: processingData.sentiment || null\n    }\n  }\n};"
      },
      "id": "function-merge-response",
      "name": "Merge Processing Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1650,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "const noteData = $('Parse Note Data').item.json;\nconst existingNote = $('Check for Duplicate').item.json;\n\nconst duplicateMessages = {\n  'uuid_exact_duplicate': 'Exact duplicate detected (same UUID and content) - skipped',\n  'content_duplicate': 'Content duplicate detected (same content, different source) - skipped'\n};\n\nconst message = duplicateMessages[existingNote.duplicateType] || 'Duplicate note detected and skipped';\n\nreturn {\n  json: {\n    success: true,\n    action: 'duplicate_skipped',\n    message: message,\n    duplicateType: existingNote.duplicateType,\n    contentHash: noteData.contentHash,\n    title: noteData.title,\n    sourceUuid: noteData.sourceUuid,\n    existingNoteId: existingNote.id,\n    existingNoteTitle: existingNote.title,\n    existingNoteCreatedAt: existingNote.created_at,\n    existingNoteUuid: existingNote.source_uuid\n  }\n};"
      },
      "id": "function-duplicate",
      "name": "Build Duplicate Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1250,
        500
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "webhook-respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1850,
        300
      ]
    }
  ],
  "connections": {
    "Webhook: Receive from Drafts": {
      "main": [
        [
          {
            "node": "Parse Note Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Note Data": {
      "main": [
        [
          {
            "node": "Check for Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Duplicate": {
      "main": [
        [
          {
            "node": "Is New Note?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is New Note?": {
      "main": [
        [
          {
            "node": "Insert Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Edit?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Edit?": {
      "main": [
        [
          {
            "node": "Update Existing Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Duplicate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Existing Note": {
      "main": [
        [
          {
            "node": "Build Update Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Update Response": {
      "main": [
        [
          {
            "node": "Trigger LLM Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Note": {
      "main": [
        [
          {
            "node": "Build Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Success Response": {
      "main": [
        [
          {
            "node": "Trigger LLM Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger LLM Processing": {
      "main": [
        [
          {
            "node": "Merge Processing Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Processing Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Duplicate Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}