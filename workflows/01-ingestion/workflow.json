{
  "name": "01-Note-Ingestion | Selene",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/drafts",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-receive",
      "name": "Webhook: Receive from Drafts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        250,
        300
      ],
      "webhookId": "selene-drafts-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Parse incoming note from Drafts app or other sources\nconst body = $input.item.json.body || $input.item.json;\nconst query = $input.item.json.query || {};\n\n// Support multiple input formats\nconst title = body.title || query.title || 'Untitled Note';\nconst content = body.content || query.content || body.text || '';\nconst timestamp = body.created_at || body.timestamp || query.timestamp || new Date().toISOString();\nconst sourceType = body.source_type || query.source_type || 'drafts';\nconst sourceUuid = body.source_uuid || query.source_uuid || null;  // UUID for draft tracking\nconst testRun = body.test_run || query.test_run || null;\nconst useTestDb = body.use_test_db || query.use_test_db || false;  // Test database flag\n\n// Validate required fields\nif (!content || content.trim().length === 0) {\n  throw new Error('Content is required and cannot be empty');\n}\n\n// Generate content hash for duplicate detection (simple hash function)\n// Using a FNV-1a hash algorithm that works without crypto module\nfunction simpleHash(str) {\n  let hash = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    hash ^= str.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (hash >>> 0).toString(16);\n}\n\nconst contentHash = simpleHash(content.trim());\n\n// Calculate metadata\nconst words = content.trim().split(/\\s+/).filter(w => w.length > 0);\nconst wordCount = words.length;\nconst characterCount = content.length;\n\n// Extract tags if present (format: #tag or #tag-with-hyphens)\nconst tagMatches = content.match(/#([\\w-]+)/g) || [];\nconst tags = tagMatches.map(t => t.substring(1));\n\nreturn {\n  json: {\n    title: title.trim(),\n    content: content.trim(),\n    contentHash: contentHash,\n    timestamp: timestamp,\n    wordCount: wordCount,\n    characterCount: characterCount,\n    tags: tags,\n    sourceType: sourceType,\n    sourceUuid: sourceUuid,\n    testRun: testRun,\n    use_test_db: useTestDb,\n    status: 'pending'\n  }\n};"
      },
      "id": "function-parse",
      "name": "Parse Note Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Check if this is feedback for Selene itself\nconst noteData = $json;\nconst tags = noteData.tags || [];\nconst isFeedback = tags.includes('selene-feedback');\nconst useTestDb = noteData.use_test_db || false;\n\nreturn {\n  json: {\n    ...noteData,\n    isFeedback: isFeedback,\n    use_test_db: useTestDb\n  }\n};"
      },
      "id": "check-feedback-tag",
      "name": "Check Feedback Tag",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        550,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isFeedback }}",
              "value2": true
            }
          ]
        }
      },
      "id": "route-feedback",
      "name": "Is Feedback?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        750,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $json;\nconst useTestDb = noteData.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\ntry {\n  const db = new Database(dbPath);\n\n  // Check for duplicate feedback\n  const existing = db.prepare('SELECT id FROM feedback_notes WHERE content_hash = ?').get(noteData.contentHash);\n  \n  if (existing) {\n    // Increment mention count instead of inserting duplicate\n    db.prepare('UPDATE feedback_notes SET mention_count = mention_count + 1 WHERE id = ?').run(existing.id);\n    db.close();\n    return {\n      json: {\n        success: true,\n        action: 'feedback_incremented',\n        feedback_id: existing.id,\n        message: 'Feedback mention count incremented',\n        testRun: noteData.testRun,\n        use_test_db: useTestDb\n      }\n    };\n  }\n\n  // Insert new feedback\n  const result = db.prepare(`\n    INSERT INTO feedback_notes (content, content_hash, created_at, test_run)\n    VALUES (?, ?, ?, ?)\n  `).run(\n    noteData.content,\n    noteData.contentHash,\n    noteData.timestamp,\n    noteData.testRun\n  );\n\n  db.close();\n\n  return {\n    json: {\n      success: true,\n      action: 'feedback_stored',\n      feedback_id: result.lastInsertRowid,\n      message: 'Feedback note stored successfully',\n      testRun: noteData.testRun,\n      use_test_db: useTestDb\n    }\n  };\n\n} catch (error) {\n  console.error('Feedback insert error:', error);\n  throw new Error('Failed to insert feedback: ' + error.message);\n}"
      },
      "id": "insert-feedback",
      "name": "Insert Feedback Note",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        950,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $json;\nconst useTestDb = noteData.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\ntry {\n  const db = new Database(dbPath, { readonly: true });\n  \n  // UUID-First Duplicate Detection Strategy\n  let result = null;\n  let duplicateType = null;\n  \n  if (noteData.sourceUuid) {\n    // Step 1: Check if UUID exists\n    const uuidQuery = `SELECT id, title, content_hash, created_at, source_uuid FROM raw_notes WHERE source_uuid = ? LIMIT 1`;\n    const uuidStmt = db.prepare(uuidQuery);\n    const uuidMatch = uuidStmt.get(noteData.sourceUuid);\n    \n    if (uuidMatch) {\n      // UUID exists - check if content changed\n      if (uuidMatch.content_hash === noteData.contentHash) {\n        // Exact duplicate (same UUID, same content)\n        result = uuidMatch;\n        duplicateType = 'uuid_exact_duplicate';\n      } else {\n        // Edit detected (same UUID, different content)\n        result = uuidMatch;\n        duplicateType = 'uuid_edit_detected';\n      }\n    } else {\n      // UUID not found - check content_hash for accidental duplicates\n      const hashQuery = `SELECT id, title, content_hash, created_at, source_uuid FROM raw_notes WHERE content_hash = ? LIMIT 1`;\n      const hashStmt = db.prepare(hashQuery);\n      const hashMatch = hashStmt.get(noteData.contentHash);\n      \n      if (hashMatch) {\n        // Same content exists with different UUID/source\n        result = hashMatch;\n        duplicateType = 'content_duplicate';\n      } else {\n        // New note\n        result = null;\n        duplicateType = 'new_note';\n      }\n    }\n  } else {\n    // No UUID provided - fall back to content_hash only (backward compatible)\n    const hashQuery = `SELECT id, title, content_hash, created_at, source_uuid FROM raw_notes WHERE content_hash = ? LIMIT 1`;\n    const hashStmt = db.prepare(hashQuery);\n    const hashMatch = hashStmt.get(noteData.contentHash);\n    \n    if (hashMatch) {\n      result = hashMatch;\n      duplicateType = 'content_duplicate';\n    } else {\n      result = null;\n      duplicateType = 'new_note';\n    }\n  }\n  \n  db.close();\n  \n  return { \n    json: result ? { \n      ...result, \n      duplicateType: duplicateType,\n      use_test_db: useTestDb\n    } : { \n      id: null, \n      duplicateType: duplicateType,\n      use_test_db: useTestDb\n    } \n  };\n  \n} catch (error) {\n  console.error('SQLite Duplicate Check Error:', error);\n  // If database doesn't exist or has errors, treat as new note\n  return { json: { id: null, duplicateType: 'new_note', use_test_db: useTestDb } };\n}"
      },
      "id": "sqlite-check-duplicate",
      "name": "Check for Duplicate",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        950,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.duplicateType === 'new_note' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "switch-is-duplicate",
      "name": "Is New Note?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1150,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.duplicateType === 'uuid_edit_detected' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "switch-is-edit",
      "name": "Is Edit?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1350,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $('Parse Note Data').item.json;\nconst existingNote = $('Check for Duplicate').item.json;\nconst useTestDb = noteData.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\ntry {\n  const db = new Database(dbPath);\n\n  // Update existing note with new content\n  // Reset status to 'pending' for re-processing\n  // Preserve original created_at\n  const updateQuery = `UPDATE raw_notes SET\n    content = ?,\n    content_hash = ?,\n    title = ?,\n    word_count = ?,\n    character_count = ?,\n    tags = ?,\n    imported_at = ?,\n    status = 'pending',\n    status_apple = 'pending_apple'\n  WHERE id = ?`;\n\n  const stmt = db.prepare(updateQuery);\n  const result = stmt.run(\n    noteData.content,\n    noteData.contentHash,\n    noteData.title,\n    noteData.wordCount,\n    noteData.characterCount,\n    JSON.stringify(noteData.tags),\n    noteData.timestamp,\n    existingNote.id\n  );\n\n  db.close();\n\n  return {\n    json: {\n      note_id: existingNote.id,\n      title: noteData.title,\n      wordCount: noteData.wordCount,\n      contentHash: noteData.contentHash,\n      sourceType: noteData.sourceType,\n      sourceUuid: noteData.sourceUuid,\n      testRun: noteData.testRun,\n      use_test_db: useTestDb,\n      action: 'updated',\n      previousHash: existingNote.content_hash\n    }\n  };\n\n} catch (error) {\n  console.error('SQLite Update Error:', error);\n  throw new Error(`Failed to update note: ${error.message}`);\n}"
      },
      "id": "sqlite-update",
      "name": "Update Existing Note",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1550,
        450
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst noteData = $('Parse Note Data').item.json;\nconst useTestDb = noteData.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\ntry {\n  const db = new Database(dbPath);\n\n  // Insert the note into raw_notes table\n  // Sets both status='pending' (for Ollama) and status_apple='pending_apple' (for Apple Intelligence)\n  const insertQuery = `INSERT INTO raw_notes (\n    title, content, content_hash, source_type, source_uuid,\n    word_count, character_count, tags,\n    created_at, imported_at, status, status_apple, test_run\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending', 'pending_apple', ?)`;\n\n  const stmt = db.prepare(insertQuery);\n  const result = stmt.run(\n    noteData.title,\n    noteData.content,\n    noteData.contentHash,\n    noteData.sourceType,\n    noteData.sourceUuid,\n    noteData.wordCount,\n    noteData.characterCount,\n    JSON.stringify(noteData.tags),\n    noteData.timestamp,\n    noteData.timestamp,\n    noteData.testRun\n  );\n\n  db.close();\n\n  return {\n    json: {\n      note_id: result.lastInsertRowid,\n      title: noteData.title,\n      wordCount: noteData.wordCount,\n      contentHash: noteData.contentHash,\n      sourceType: noteData.sourceType,\n      sourceUuid: noteData.sourceUuid,\n      testRun: noteData.testRun,\n      use_test_db: useTestDb\n    }\n  };\n\n} catch (error) {\n  console.error('SQLite Insert Error:', error);\n  throw new Error(`Failed to insert note: ${error.message}`);\n}"
      },
      "id": "sqlite-insert",
      "name": "Insert Note",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1350,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "const updateResult = $json;\nconst useTestDb = updateResult.use_test_db || false;\n\nreturn {\n  json: {\n    success: true,\n    action: 'updated',\n    message: 'Note content updated - edit detected',\n    noteId: updateResult.note_id,\n    title: updateResult.title,\n    wordCount: updateResult.wordCount,\n    contentHash: updateResult.contentHash,\n    previousHash: updateResult.previousHash,\n    sourceType: updateResult.sourceType,\n    sourceUuid: updateResult.sourceUuid,\n    status: 'pending',\n    use_test_db: useTestDb\n  }\n};"
      },
      "id": "function-update",
      "name": "Build Update Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1750,
        450
      ]
    },
    {
      "parameters": {
        "functionCode": "const insertResult = $json;\nconst useTestDb = insertResult.use_test_db || false;\n\nreturn {\n  json: {\n    success: true,\n    action: 'stored',\n    message: 'Note successfully ingested into raw_notes table',\n    noteId: insertResult.note_id,\n    title: insertResult.title,\n    wordCount: insertResult.wordCount,\n    contentHash: insertResult.contentHash,\n    sourceType: insertResult.sourceType,\n    status: 'pending',\n    use_test_db: useTestDb\n  }\n};"
      },
      "id": "function-success",
      "name": "Build Success Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1550,
        300
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/api/process-note",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "noteId",
              "value": "={{ $json.noteId }}"
            }
          ]
        },
        "options": {
          "timeout": 120000,
          "redirect": {
            "redirect": {}
          }
        }
      },
      "id": "http-trigger-processing",
      "name": "Trigger LLM Processing",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        1750,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "const ingestionData = $('Build Success Response').item.json;\nconst processingData = $json;\nconst useTestDb = ingestionData.use_test_db || false;\n\nreturn {\n  json: {\n    success: true,\n    action: 'stored_and_processed',\n    message: 'Note ingested and LLM processing triggered successfully',\n    noteId: ingestionData.noteId,\n    title: ingestionData.title,\n    wordCount: ingestionData.wordCount,\n    use_test_db: useTestDb,\n    processing: {\n      status: processingData.success ? 'processing' : 'queued',\n      conceptsExtracted: processingData.conceptsExtracted || 0,\n      primaryTheme: processingData.primaryTheme || null,\n      sentiment: processingData.sentiment || null\n    }\n  }\n};"
      },
      "id": "function-merge-response",
      "name": "Merge Processing Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1950,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "const noteData = $('Parse Note Data').item.json;\nconst existingNote = $('Check for Duplicate').item.json;\nconst useTestDb = noteData.use_test_db || false;\n\nconst duplicateMessages = {\n  'uuid_exact_duplicate': 'Exact duplicate detected (same UUID and content) - skipped',\n  'content_duplicate': 'Content duplicate detected (same content, different source) - skipped'\n};\n\nconst message = duplicateMessages[existingNote.duplicateType] || 'Duplicate note detected and skipped';\n\nreturn {\n  json: {\n    success: true,\n    action: 'duplicate_skipped',\n    message: message,\n    duplicateType: existingNote.duplicateType,\n    contentHash: noteData.contentHash,\n    title: noteData.title,\n    sourceUuid: noteData.sourceUuid,\n    existingNoteId: existingNote.id,\n    existingNoteTitle: existingNote.title,\n    existingNoteCreatedAt: existingNote.created_at,\n    existingNoteUuid: existingNote.source_uuid,\n    use_test_db: useTestDb\n  }\n};"
      },
      "id": "function-duplicate",
      "name": "Build Duplicate Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1550,
        600
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "webhook-respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2550,
        200
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst feedbackResult = $json;\nconst useTestDb = feedbackResult.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\nconsole.log('[Build Classification Prompt] Received:', feedbackResult.action);\n\n// If this was just an increment, skip classification\nif (feedbackResult.action === 'feedback_incremented') {\n  console.log('[Build Classification Prompt] Skipping - increment only');\n  return {\n    json: {\n      ...feedbackResult,\n      skipClassification: true,\n      use_test_db: useTestDb\n    }\n  };\n}\n\nconst feedbackId = feedbackResult.feedback_id;\nconsole.log('[Build Classification Prompt] Processing feedback ID:', feedbackId);\n\n// Read the feedback content from database\nconst db = new Database(dbPath, { readonly: true });\nconst feedback = db.prepare('SELECT content FROM feedback_notes WHERE id = ?').get(feedbackId);\n\n// Get existing backlog titles from database for duplicate detection\nconst existingItems = db.prepare(`\n  SELECT backlog_id, substr(content, 1, 60) as title\n  FROM feedback_notes\n  WHERE backlog_id IS NOT NULL AND status = 'added_to_backlog'\n  ORDER BY backlog_id\n`).all();\n\ndb.close();\n\nif (!feedback) {\n  throw new Error('Feedback not found: ' + feedbackId);\n}\n\nconst existingTitles = existingItems.map(i => i.backlog_id + ': ' + i.title);\n\n// Build the prompt\nconst promptTemplate = `You are classifying user feedback about the Selene app into backlog items.\n\nFEEDBACK:\n\"\"\"\n${feedback.content}\n\"\"\"\n\nEXISTING BACKLOG TITLES (for duplicate detection):\n${existingTitles.length > 0 ? existingTitles.join('\\n') : '(none)'}\n\nClassify this feedback into exactly ONE category:\n- user_story: A need expressed from user perspective (\"I wanted...\", \"I couldn't...\")\n- feature_request: A specific new capability (\"Add X\", \"Support Y\")\n- bug: Something broken or producing wrong results\n- improvement: Enhancement to existing functionality\n- noise: Not actionable (test messages, incomplete thoughts, off-topic)\n\nRespond in JSON only:\n{\n  \"category\": \"user_story|feature_request|bug|improvement|noise\",\n  \"title\": \"Brief title (max 60 chars, starts with verb for bugs/improvements)\",\n  \"description\": \"One sentence explaining the need or issue\",\n  \"confidence\": 0.0-1.0,\n  \"duplicate_of\": \"ID if matches existing item, null otherwise\",\n  \"reasoning\": \"Why this category and title\"\n}`;\n\nconsole.log('[Build Classification Prompt] Built prompt for feedback:', feedbackId);\n\nreturn {\n  json: {\n    feedbackId: feedbackId,\n    feedbackContent: feedback.content,\n    prompt: promptTemplate,\n    existingTitles: existingTitles,\n    testRun: feedbackResult.testRun,\n    use_test_db: useTestDb,\n    skipClassification: false\n  }\n};"
      },
      "id": "build-classification-prompt",
      "name": "Build Classification Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1150,
        200
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.skipClassification }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-skip-classification",
      "name": "Skip Classification?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1350,
        200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.OLLAMA_BASE_URL }}/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral:7b\",\n  \"prompt\": {{ JSON.stringify($json.prompt) }},\n  \"stream\": false,\n  \"format\": \"json\"\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "ollama-classify",
      "name": "Ollama: Classify Feedback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1550,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "const ollamaResponse = $json;\nconst prevData = $('Build Classification Prompt').item.json;\nconst useTestDb = prevData.use_test_db || false;\n\nlet classification;\ntry {\n  const responseText = ollamaResponse.response || '';\n  classification = JSON.parse(responseText);\n} catch (e) {\n  classification = {\n    category: 'noise',\n    title: 'Unparseable feedback',\n    description: 'AI could not classify this feedback',\n    confidence: 0,\n    duplicate_of: null,\n    reasoning: 'JSON parse error: ' + e.message\n  };\n}\n\nconst validCategories = ['user_story', 'feature_request', 'bug', 'improvement', 'noise'];\nif (!validCategories.includes(classification.category)) {\n  classification.category = 'noise';\n}\n\nif (classification.confidence < 0.5) {\n  classification.category = 'noise';\n  classification.reasoning = 'Low confidence (' + classification.confidence + '): ' + classification.reasoning;\n}\n\nreturn {\n  json: {\n    feedbackId: prevData.feedbackId,\n    feedbackContent: prevData.feedbackContent,\n    existingTitles: prevData.existingTitles,\n    testRun: prevData.testRun,\n    use_test_db: useTestDb,\n    classification: classification\n  }\n};"
      },
      "id": "parse-classification",
      "name": "Parse Classification",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1750,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.classification.category === 'noise' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "route-by-category",
      "name": "Is Noise?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1950,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.classification.duplicate_of !== null && $json.classification.duplicate_of !== '' }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-duplicate-backlog",
      "name": "Is Duplicate?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2150,
        400
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst data = $json;\nconst classification = data.classification;\nconst testRun = data.testRun;\nconst useTestDb = data.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\nconst categoryMap = {\n  'user_story': 'US',\n  'feature_request': 'FR',\n  'bug': 'BUG',\n  'improvement': 'IMP'\n};\n\nconst prefix = categoryMap[classification.category];\nif (!prefix) {\n  throw new Error('Invalid category for backlog: ' + classification.category);\n}\n\nconst db = new Database(dbPath);\n\n// Get max existing backlog_id for this category prefix\nconst maxResult = db.prepare(`\n  SELECT backlog_id FROM feedback_notes\n  WHERE backlog_id LIKE ? || '-%'\n  ORDER BY CAST(SUBSTR(backlog_id, LENGTH(?) + 2) AS INTEGER) DESC\n  LIMIT 1\n`).get(prefix, prefix);\n\nlet nextNum = 1;\nif (maxResult && maxResult.backlog_id) {\n  const match = maxResult.backlog_id.match(new RegExp(prefix + '-(\\\\d+)'));\n  if (match) {\n    nextNum = parseInt(match[1]) + 1;\n  }\n}\n\nconst newId = prefix + '-' + String(nextNum).padStart(3, '0');\n\ndb.close();\n\nconsole.log('[Append to Backlog] Generated ID:', newId, 'for category:', classification.category);\n\nreturn {\n  json: {\n    feedbackId: data.feedbackId,\n    backlogId: newId,\n    category: classification.category,\n    title: classification.title,\n    testRun: testRun,\n    use_test_db: useTestDb\n  }\n};"
      },
      "id": "append-to-backlog",
      "name": "Append to Backlog",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2350,
        500
      ]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\nconst data = $json;\nconst useTestDb = data.use_test_db || false;\nconst dbPath = useTestDb\n  ? process.env.SELENE_TEST_DB_PATH\n  : process.env.SELENE_DB_PATH;\n\nlet status, backlogId, category, confidence, reasoning, feedbackId;\n\nif (data.backlogId) {\n  status = 'added_to_backlog';\n  backlogId = data.backlogId;\n  category = data.category;\n  confidence = null;\n  reasoning = null;\n  feedbackId = data.feedbackId;\n} else if (data.classification) {\n  const c = data.classification;\n  if (c.duplicate_of) {\n    status = 'duplicate';\n    backlogId = c.duplicate_of;\n  } else {\n    status = 'noise';\n    backlogId = null;\n  }\n  category = c.category;\n  confidence = c.confidence;\n  reasoning = c.reasoning;\n  feedbackId = data.feedbackId;\n} else if (data.skipClassification) {\n  return {\n    json: {\n      success: true,\n      action: 'feedback_incremented',\n      message: 'Feedback mention count incremented (no classification needed)',\n      feedbackId: data.feedback_id,\n      use_test_db: useTestDb\n    }\n  };\n} else {\n  throw new Error('Unknown data path');\n}\n\nconst db = new Database(dbPath);\n\ndb.prepare(`\n  UPDATE feedback_notes\n  SET status = ?, category = ?, backlog_id = ?,\n      classified_at = datetime('now'),\n      ai_confidence = ?, ai_reasoning = ?\n  WHERE id = ?\n`).run(\n  status,\n  category,\n  backlogId,\n  confidence,\n  reasoning,\n  feedbackId\n);\n\ndb.close();\n\nreturn {\n  json: {\n    success: true,\n    action: 'feedback_classified',\n    feedbackId: feedbackId,\n    status: status,\n    category: category,\n    backlogId: backlogId,\n    testRun: data.testRun,\n    use_test_db: useTestDb\n  }\n};"
      },
      "id": "update-feedback-status",
      "name": "Update Feedback Status",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2350,
        200
      ]
    }
  ],
  "connections": {
    "Webhook: Receive from Drafts": {
      "main": [
        [
          {
            "node": "Parse Note Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Note Data": {
      "main": [
        [
          {
            "node": "Check Feedback Tag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Feedback Tag": {
      "main": [
        [
          {
            "node": "Is Feedback?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Feedback?": {
      "main": [
        [
          {
            "node": "Insert Feedback Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check for Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Feedback Note": {
      "main": [
        [
          {
            "node": "Build Classification Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Classification Prompt": {
      "main": [
        [
          {
            "node": "Skip Classification?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Classification?": {
      "main": [
        [
          {
            "node": "Update Feedback Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Ollama: Classify Feedback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama: Classify Feedback": {
      "main": [
        [
          {
            "node": "Parse Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Classification": {
      "main": [
        [
          {
            "node": "Is Noise?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Noise?": {
      "main": [
        [
          {
            "node": "Update Feedback Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Duplicate?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Duplicate?": {
      "main": [
        [
          {
            "node": "Update Feedback Status",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Append to Backlog",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Append to Backlog": {
      "main": [
        [
          {
            "node": "Update Feedback Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Feedback Status": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Duplicate": {
      "main": [
        [
          {
            "node": "Is New Note?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is New Note?": {
      "main": [
        [
          {
            "node": "Insert Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Is Edit?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Edit?": {
      "main": [
        [
          {
            "node": "Update Existing Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Duplicate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Existing Note": {
      "main": [
        [
          {
            "node": "Build Update Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Update Response": {
      "main": [
        [
          {
            "node": "Trigger LLM Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Note": {
      "main": [
        [
          {
            "node": "Build Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Success Response": {
      "main": [
        [
          {
            "node": "Trigger LLM Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger LLM Processing": {
      "main": [
        [
          {
            "node": "Merge Processing Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Processing Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Duplicate Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}