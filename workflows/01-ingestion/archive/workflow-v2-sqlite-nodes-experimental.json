{
  "name": "Selene: Note Ingestion v2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/drafts",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-receive",
      "name": "Webhook: Receive from Drafts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "selene-drafts-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Parse incoming note from Drafts app or other sources\nconst body = $input.item.json.body || $input.item.json;\nconst query = $input.item.json.query || {};\n\n// Support multiple input formats\nconst title = body.title || query.title || 'Untitled Note';\nconst content = body.content || query.content || body.text || '';\nconst timestamp = body.created_at || body.timestamp || query.timestamp || new Date().toISOString();\nconst sourceType = body.source_type || query.source_type || 'drafts';\n\n// Validate required fields\nif (!content || content.trim().length === 0) {\n  throw new Error('Content is required and cannot be empty');\n}\n\n// Generate content hash for duplicate detection (simple hash function)\n// Using a FNV-1a hash algorithm that works without crypto module\nfunction simpleHash(str) {\n  let hash = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    hash ^= str.charCodeAt(i);\n    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n  }\n  return (hash >>> 0).toString(16);\n}\n\nconst contentHash = simpleHash(content.trim());\n\n// Calculate metadata\nconst words = content.trim().split(/\\s+/).filter(w => w.length > 0);\nconst wordCount = words.length;\nconst characterCount = content.length;\n\n// Extract tags if present (format: #tag)\nconst tagMatches = content.match(/#(\\w+)/g) || [];\nconst tags = tagMatches.map(t => t.substring(1));\n\nreturn {\n  json: {\n    title: title.trim(),\n    content: content.trim(),\n    contentHash: contentHash,\n    timestamp: timestamp,\n    wordCount: wordCount,\n    characterCount: characterCount,\n    tags: JSON.stringify(tags),\n    sourceType: sourceType,\n    status: 'pending'\n  }\n};"
      },
      "id": "function-parse",
      "name": "Parse Note Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, title, created_at FROM raw_notes WHERE content_hash = :contentHash LIMIT 1",
        "additionalFields": {
          "params": {
            "params": [
              {
                "name": "contentHash",
                "value": "={{ $json.contentHash }}"
              }
            ]
          }
        }
      },
      "id": "sqlite-check-duplicate",
      "name": "Check for Duplicate",
      "type": "n8n-nodes-sqlite.sqlite",
      "typeVersion": 1,
      "position": [650, 300],
      "credentials": {
        "sqliteApi": {
          "id": "1",
          "name": "Selene Database"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.id === undefined || $json.id === null }}",
              "value2": true
            }
          ]
        }
      },
      "id": "switch-is-duplicate",
      "name": "Is New Note?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO raw_notes (title, content, content_hash, source_type, word_count, character_count, tags, created_at, imported_at, status) VALUES (:title, :content, :contentHash, :sourceType, :wordCount, :characterCount, :tags, :timestamp, datetime('now'), 'pending')",
        "additionalFields": {
          "params": {
            "params": [
              {
                "name": "title",
                "value": "={{ $('Parse Note Data').item.json.title }}"
              },
              {
                "name": "content",
                "value": "={{ $('Parse Note Data').item.json.content }}"
              },
              {
                "name": "contentHash",
                "value": "={{ $('Parse Note Data').item.json.contentHash }}"
              },
              {
                "name": "sourceType",
                "value": "={{ $('Parse Note Data').item.json.sourceType }}"
              },
              {
                "name": "wordCount",
                "value": "={{ $('Parse Note Data').item.json.wordCount }}"
              },
              {
                "name": "characterCount",
                "value": "={{ $('Parse Note Data').item.json.characterCount }}"
              },
              {
                "name": "tags",
                "value": "={{ $('Parse Note Data').item.json.tags }}"
              },
              {
                "name": "timestamp",
                "value": "={{ $('Parse Note Data').item.json.timestamp }}"
              }
            ]
          }
        }
      },
      "id": "sqlite-insert",
      "name": "Insert Note",
      "type": "n8n-nodes-sqlite.sqlite",
      "typeVersion": 1,
      "position": [1050, 200],
      "credentials": {
        "sqliteApi": {
          "id": "1",
          "name": "Selene Database"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "const noteData = $('Parse Note Data').item.json;\n\nreturn {\n  json: {\n    success: true,\n    action: 'stored',\n    message: 'Note successfully ingested into raw_notes table',\n    title: noteData.title,\n    wordCount: noteData.wordCount,\n    contentHash: noteData.contentHash,\n    sourceType: noteData.sourceType,\n    status: 'pending'\n  }\n};"
      },
      "id": "function-success",
      "name": "Build Success Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "functionCode": "const noteData = $('Parse Note Data').item.json;\nconst existingNote = $('Check for Duplicate').item.json;\n\nreturn {\n  json: {\n    success: true,\n    action: 'duplicate_skipped',\n    message: 'Duplicate note detected and skipped',\n    contentHash: noteData.contentHash,\n    title: noteData.title,\n    existingNoteId: existingNote.id,\n    existingNoteTitle: existingNote.title,\n    existingNoteCreatedAt: existingNote.created_at\n  }\n};"
      },
      "id": "function-duplicate",
      "name": "Build Duplicate Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 400]
    }
  ],
  "connections": {
    "Webhook: Receive from Drafts": {
      "main": [
        [
          {
            "node": "Parse Note Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Note Data": {
      "main": [
        [
          {
            "node": "Check for Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Duplicate": {
      "main": [
        [
          {
            "node": "Is New Note?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is New Note?": {
      "main": [
        [
          {
            "node": "Insert Note",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Duplicate Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Note": {
      "main": [
        [
          {
            "node": "Build Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Success Response": {
      "main": [
        [
          {
            "node": "Webhook: Receive from Drafts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Duplicate Response": {
      "main": [
        [
          {
            "node": "Webhook: Receive from Drafts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}
