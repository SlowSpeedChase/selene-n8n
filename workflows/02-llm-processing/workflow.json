{
  "name": "02-LLM-Processing | Selene",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/process-note",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook: Process Note",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "selene-process-note-webhook"
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\n// Get note ID from webhook payload\nconst body = $input.item.json.body || $input.item.json;\nconst noteId = body.noteId || body.note_id;\n\nif (!noteId) {\n  throw new Error('noteId is required in webhook payload');\n}\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  // Get note data and mark as 'processing' atomically\n  const selectQuery = `SELECT id, title, content, created_at\n                       FROM raw_notes\n                       WHERE id = ? AND status = 'pending'\n                       LIMIT 1`;\n  \n  const result = db.prepare(selectQuery).all(noteId);\n  \n  if (result.length > 0) {\n    // Mark as 'processing' to prevent duplicate processing\n    const updateQuery = `UPDATE raw_notes \n                        SET status = 'processing' \n                        WHERE id = ? AND status = 'pending'`;\n    \n    const changes = db.prepare(updateQuery).run(noteId);\n    \n    db.close();\n    \n    // Only proceed if we successfully locked it\n    if (changes.changes > 0) {\n      return result.map(row => ({ json: row }));\n    } else {\n      throw new Error(`Note ${noteId} is already being processed`);\n    }\n  } else {\n    db.close();\n    throw new Error(`Note ${noteId} not found or already processed`);\n  }\n  \n} catch (error) {\n  console.error('SQLite Error:', error);\n  throw new Error('Database query failed: ' + error.message);\n}"
      },
      "id": "sqlite-get-pending",
      "name": "Get Note and Lock",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "const content = $json.content;\nconst title = $json.title;\nconst noteId = $json.id;\n\n// Detect note type based on keywords\nfunction detectNoteType(text) {\n  const lower = text.toLowerCase();\n\n  if (/(meeting|met with|discussed|decided|action items)/i.test(lower)) {\n    return 'meeting';\n  } else if (/(docker|api|database|code|function|git|python|javascript)/i.test(lower)) {\n    return 'technical';\n  } else if (/(idea|concept|what if|could we|brainstorm)/i.test(lower)) {\n    return 'idea';\n  } else if (/(i feel|i think|my goal|personally|overwhelmed|feeling)/i.test(lower)) {\n    return 'personal';\n  } else if (/(todo|must do|deadline|task|complete)/i.test(lower)) {\n    return 'task';\n  } else if (/(learned|realized|thinking about|reflecting)/i.test(lower)) {\n    return 'reflection';\n  }\n  return 'general';\n}\n\nconst noteType = detectNoteType(content);\n\n// Context-specific guidance\nconst contextGuidance = {\n  meeting: 'MEETING CONTEXT: Focus on decisions made, action items, people involved, topics discussed, deadlines, and outcomes.',\n  technical: 'TECHNICAL CONTEXT: Focus on technologies, tools, methods, problems, solutions, and technical concepts discussed.',\n  idea: 'IDEA CONTEXT: Focus on the core idea, implementation methods, challenges, benefits, and related concepts.',\n  personal: 'PERSONAL CONTEXT: Focus on activities, goals, challenges, areas of focus, and actionable items rather than emotions.',\n  task: 'TASK CONTEXT: Focus on the main task, subtasks, tools needed, people involved, and deadlines.',\n  reflection: 'REFLECTION CONTEXT: Focus on topics being reflected upon, lessons learned, areas for improvement, and actionable insights.',\n  general: 'GENERAL CONTEXT: Focus on the main topics, subjects, activities, and key points discussed in the note.'\n};\n\n// Build system prompt for concept extraction\nconst systemPrompt = `You are a concept extraction specialist. Your job is to identify the key concepts, topics, and subjects from text with high accuracy.\n\nCRITICAL INSTRUCTIONS:\n- Extract 3-5 of the most important concepts from the given text\n- Focus on concrete topics, themes, and subjects discussed (not abstract feelings)\n- Concepts should be 1-4 words each (short, meaningful phrases)\n- Return ONLY valid JSON in this exact format:\n{\"concepts\": [\"concept1\", \"concept2\", \"concept3\"], \"confidence_scores\": {\"concept1\": 0.95, \"concept2\": 0.85, \"concept3\": 0.75}}\n- Confidence scores: 0.0-1.0 (higher = more confident the concept is important)\n- Do NOT include any other text, explanations, or formatting\n- If unsure, prefer concrete nouns over abstract concepts\n\n${contextGuidance[noteType]}`;\n\n// Build user prompt\nconst contentPreview = content.substring(0, 2000);\nconst userPrompt = `Extract the key concepts from this note:\n\n${contentPreview}\n\nRemember: Return ONLY the JSON response, no other text.`;\n\nreturn {\n  json: {\n    noteId: noteId,\n    title: title,\n    content: content,\n    noteType: noteType,\n    systemPrompt: systemPrompt,\n    userPrompt: userPrompt\n  }\n};"
      },
      "id": "function-build-concept-prompt",
      "name": "Build Concept Extraction Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"mistral:7b\",\n  \"prompt\": $json.userPrompt,\n  \"system\": $json.systemPrompt,\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.3,\n    \"num_predict\": 2000\n  }\n} }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "http-ollama-concepts",
      "name": "Ollama: Extract Concepts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1050, 200]
    },
    {
      "parameters": {
        "functionCode": "const response = $json.response;\nconst noteId = $('Build Concept Extraction Prompt').item.json.noteId;\n\n// Try to parse JSON response\nlet concepts = [];\nlet confidenceScores = {};\nlet processingNotes = '';\n\ntry {\n  const parsed = JSON.parse(response.trim());\n\n  if (Array.isArray(parsed)) {\n    concepts = parsed.slice(0, 5);\n    confidenceScores = Object.fromEntries(concepts.map(c => [c, 0.7]));\n    processingNotes = 'JSON array parsed';\n  } else if (parsed.concepts) {\n    concepts = parsed.concepts.slice(0, 5);\n    confidenceScores = parsed.confidence_scores || {};\n\n    // Ensure all concepts have confidence scores\n    concepts.forEach(concept => {\n      if (!confidenceScores[concept]) {\n        confidenceScores[concept] = 0.7;\n      }\n    });\n    processingNotes = 'JSON parsing successful';\n  } else {\n    throw new Error('Invalid JSON structure');\n  }\n} catch (e) {\n  // Fallback: extract from non-JSON response\n  processingNotes = 'Fallback extraction used';\n  const lines = response.split('\\n');\n  for (const line of lines) {\n    const bulletMatch = line.match(/^[-*â€¢]\\s*(.+)$/);\n    const numberMatch = line.match(/^\\d+\\.?\\s*(.+)$/);\n    const match = bulletMatch || numberMatch;\n    \n    if (match) {\n      const concept = match[1].trim().replace(/[.,!?;:]+$/, '');\n      if (concept.split(' ').length <= 4 && concept.length > 2) {\n        concepts.push(concept);\n        confidenceScores[concept] = 0.5;\n      }\n    }\n    if (concepts.length >= 5) break;\n  }\n\n  // If still no concepts, extract capitalized phrases\n  if (concepts.length === 0) {\n    const capWords = response.match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g) || [];\n    concepts = [...new Set(capWords)].slice(0, 5);\n    concepts.forEach(c => confidenceScores[c] = 0.3);\n    processingNotes += ' + capitalized word extraction';\n  }\n}\n\nreturn {\n  json: {\n    noteId: noteId,\n    concepts: concepts,\n    conceptConfidence: confidenceScores,\n    processingNotes: processingNotes\n  }\n};"
      },
      "id": "function-parse-concepts",
      "name": "Parse Concepts",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "functionCode": "const noteId = $json.noteId;\nconst content = $('Build Concept Extraction Prompt').item.json.content;\nconst noteType = $('Build Concept Extraction Prompt').item.json.noteType;\n\n// Standard theme vocabulary\nconst standardThemes = [\n  'work', 'meeting', 'project', 'task', 'personal', 'health',\n  'learning', 'reflection', 'idea', 'problem_solving', 'planning',\n  'technical', 'tools', 'process', 'communication', 'collaboration',\n  'feedback', 'improvement', 'decision', 'notes'\n];\n\n// Context guidance\nconst contextGuidance = {\n  meeting: 'MEETING CONTEXT: Primary themes often include \"meeting\", \"project\", or \"planning\". Secondary themes might be \"decision\", \"collaboration\", or \"task\".',\n  technical: 'TECHNICAL CONTEXT: Primary themes often include \"technical\", \"tools\", or \"problem_solving\". Secondary themes might be \"learning\", \"process\", or \"improvement\".',\n  idea: 'IDEA CONTEXT: Primary theme is usually \"idea\" or \"planning\". Secondary themes might be \"innovation\", \"problem_solving\", or the domain area.',\n  personal: 'PERSONAL CONTEXT: Primary themes often include \"personal\", \"health\", or \"reflection\". Secondary themes might be \"planning\", \"improvement\", or \"learning\".',\n  task: 'TASK CONTEXT: Primary theme is usually \"task\" or \"work\". Secondary themes might be \"planning\", \"project\", or the specific domain.',\n  reflection: 'REFLECTION CONTEXT: Primary theme is usually \"reflection\" or \"learning\". Secondary themes might be \"improvement\", \"personal\", or \"planning\".',\n  general: 'GENERAL CONTEXT: Analyze the main subject matter and choose the most appropriate theme from the standard vocabulary.'\n};\n\nconst systemPrompt = `You are a theme detection specialist. Your job is to identify the main themes and categories of text content.\n\nCRITICAL INSTRUCTIONS:\n- Identify ONE primary theme and 1-2 secondary themes from the given text\n- Themes should be 1-3 words describing the general category or subject area\n- Use these standard themes when possible: ${standardThemes.join(', ')}\n- Return ONLY valid JSON in this exact format:\n{\"primary_theme\": \"main_theme\", \"secondary_themes\": [\"theme2\", \"theme3\"], \"confidence\": 0.85}\n- Confidence: 0.0-1.0 (higher = more confident the theme classification is accurate)\n- Primary theme should be the most prominent category\n- Secondary themes should be distinctly different from primary theme\n- Do NOT include any other text, explanations, or formatting\n\n${contextGuidance[noteType]}`;\n\nconst contentPreview = content.substring(0, 2000);\nconst userPrompt = `Identify the main themes from this note:\n\n${contentPreview}\n\nRemember: Return ONLY the JSON response with primary and secondary themes.`;\n\nreturn {\n  json: {\n    noteId: noteId,\n    systemPrompt: systemPrompt,\n    userPrompt: userPrompt\n  }\n};"
      },
      "id": "function-build-theme-prompt",
      "name": "Build Theme Detection Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"mistral:7b\",\n  \"prompt\": $json.userPrompt,\n  \"system\": $json.systemPrompt,\n  \"stream\": false,\n  \"options\": {\n    \"temperature\": 0.3,\n    \"num_predict\": 1000\n  }\n} }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "http-ollama-themes",
      "name": "Ollama: Detect Themes",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "functionCode": "const response = $json.response;\nconst noteId = $('Build Theme Detection Prompt').item.json.noteId;\nconst concepts = $('Parse Concepts').item.json.concepts;\nconst conceptConfidence = $('Parse Concepts').item.json.conceptConfidence;\n\n// Parse theme response\nlet primaryTheme = 'notes';\nlet secondaryThemes = [];\nlet confidence = 0.0;\n\ntry {\n  const parsed = JSON.parse(response.trim());\n\n  if (parsed.primary_theme) {\n    primaryTheme = parsed.primary_theme.toLowerCase().replace(/\\s+/g, '_');\n    secondaryThemes = (parsed.secondary_themes || []).map(t =>\n      t.toLowerCase().replace(/\\s+/g, '_')\n    ).slice(0, 2).filter(t => t !== primaryTheme);\n    confidence = parsed.confidence || 0.5;\n  }\n} catch (e) {\n  // Fallback: try to extract theme from response text\n  const themeMatch = response.match(/theme[:\\s]*[\"']?([a-z_]+)[\"']?/i);\n  if (themeMatch) {\n    primaryTheme = themeMatch[1].toLowerCase().replace(/\\s+/g, '_');\n    confidence = 0.3;\n  } else {\n    primaryTheme = 'notes';\n    confidence = 0.2;\n  }\n}\n\nreturn {\n  json: {\n    noteId: noteId,\n    concepts: concepts,\n    conceptConfidence: conceptConfidence,\n    primaryTheme: primaryTheme,\n    secondaryThemes: secondaryThemes,\n    themeConfidence: confidence,\n    processedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "function-parse-themes",
      "name": "Parse Themes",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\n\ntry {\n  const db = new Database('/selene/data/selene.db');\n  \n  // Get the created_at from raw_notes for proper time-based analysis\n  const noteQuery = `SELECT created_at FROM raw_notes WHERE id = ?`;\n  const noteData = db.prepare(noteQuery).get($json.noteId);\n  \n  if (!noteData) {\n    db.close();\n    throw new Error(`Note ${$json.noteId} not found`);\n  }\n  \n  // Update raw_notes status from 'processing' to 'processed'\n  const updateQuery = `UPDATE raw_notes \n                      SET status = 'processed', processed_at = datetime('now') \n                      WHERE id = ? AND status = 'processing'`;\n  db.prepare(updateQuery).run($json.noteId);\n  \n  // Insert processed results (without sentiment - that's handled by workflow 05)\n  const insertQuery = `INSERT INTO processed_notes (\n    raw_note_id, concepts, concept_confidence,\n    primary_theme, secondary_themes, theme_confidence,\n    note_created_at, processed_at\n  ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;\n  \n  const result = db.prepare(insertQuery).run(\n    $json.noteId,\n    JSON.stringify($json.concepts),\n    JSON.stringify($json.conceptConfidence),\n    $json.primaryTheme,\n    JSON.stringify($json.secondaryThemes),\n    $json.themeConfidence,\n    noteData.created_at,\n    $json.processedAt\n  );\n  \n  db.close();\n  \n  return [{ json: { processedNoteId: result.lastInsertRowid, rawNoteId: $json.noteId } }];\n  \n} catch (error) {\n  console.error('SQLite Update Error:', error);\n  throw new Error('Database update failed: ' + error.message);\n}"
      },
      "id": "sqlite-update-processed",
      "name": "Update Processed Note",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/api/analyze-sentiment",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"processedNoteId\": $json.processedNoteId, \"rawNoteId\": $json.rawNoteId } }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "http-trigger-sentiment",
      "name": "Trigger Sentiment Analysis",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2050, 200]
    },
    {
      "parameters": {
        "functionCode": "const processedNoteId = $('Update Processed Note').item.json.processedNoteId;\nconst rawNoteId = $('Update Processed Note').item.json.rawNoteId;\nconst concepts = $('Parse Themes').item.json.concepts;\nconst theme = $('Parse Themes').item.json.primaryTheme;\n\nreturn {\n  json: {\n    success: true,\n    processedNoteId: processedNoteId,\n    rawNoteId: rawNoteId,\n    conceptsExtracted: concepts.length,\n    primaryTheme: theme,\n    message: `Note ${rawNoteId} processed successfully, sentiment analysis triggered`\n  }\n};"
      },
      "id": "function-completion",
      "name": "Build Completion Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2250, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "webhook-respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2450, 200]
    }
  ],
  "connections": {
    "Webhook: Process Note": {
      "main": [
        [
          {
            "node": "Get Note and Lock",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Note and Lock": {
      "main": [
        [
          {
            "node": "Build Concept Extraction Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Concept Extraction Prompt": {
      "main": [
        [
          {
            "node": "Ollama: Extract Concepts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama: Extract Concepts": {
      "main": [
        [
          {
            "node": "Parse Concepts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Concepts": {
      "main": [
        [
          {
            "node": "Build Theme Detection Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Theme Detection Prompt": {
      "main": [
        [
          {
            "node": "Ollama: Detect Themes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama: Detect Themes": {
      "main": [
        [
          {
            "node": "Parse Themes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Themes": {
      "main": [
        [
          {
            "node": "Update Processed Note",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Processed Note": {
      "main": [
        [
          {
            "node": "Trigger Sentiment Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Sentiment Analysis": {
      "main": [
        [
          {
            "node": "Build Completion Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Completion Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "executionTimeout": 300,
    "timezone": "America/Los_Angeles"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "meta": {
    "instanceId": "selene-local"
  },
  "pinData": {}
}
