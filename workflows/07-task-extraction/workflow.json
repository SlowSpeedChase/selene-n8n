{
  "name": "07-Task-Extraction",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "task-extraction",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "selene-task-extraction-webhook"
    },
    {
      "parameters": {
        "functionCode": "const db = require('better-sqlite3')('/selene/data/selene.db');\n\ntry {\n  // Handle both webhook body format and direct JSON\n  const body = $input.item.json.body || $input.item.json;\n  const rawNoteId = body.raw_note_id;\n  const testRun = body.test_run || null;\n\n  if (!rawNoteId) {\n    throw new Error('raw_note_id is required');\n  }\n\n  const query = `\n    SELECT\n      rn.id as raw_note_id,\n      rn.content,\n      rn.tags,\n      pn.id as processed_note_id,\n      pn.concepts,\n      pn.primary_theme,\n      pn.secondary_themes as themes,\n      sh.energy_level,\n      sh.emotional_tone,\n      sh.adhd_markers\n    FROM raw_notes rn\n    LEFT JOIN processed_notes pn ON rn.id = pn.raw_note_id\n    LEFT JOIN sentiment_history sh ON pn.id = sh.processed_note_id\n    WHERE rn.id = ?\n    LIMIT 1\n  `;\n\n  const row = db.prepare(query).get(rawNoteId);\n\n  if (!row) {\n    throw new Error(`Note not found: ${rawNoteId}`);\n  }\n\n  return {\n    json: {\n      ...row,\n      test_run: testRun\n    }\n  };\n} finally {\n  db.close();\n}"
      },
      "id": "fetch-note-data",
      "name": "Fetch Note Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "const note = $input.item.json;\n\n// Build classification prompt from the template\nconst prompt = `You are a note classification assistant for an ADHD-optimized knowledge management system.\n\nYour task is to analyze a note and classify it into ONE of three categories based on its actionability.\n\n## CLASSIFICATION CATEGORIES\n\n### 1. actionable\nClear, specific task that can be done NOW.\n\nCriteria:\n- Contains a clear verb + specific object (e.g., \"Call dentist\", \"Fix login bug\")\n- Can be completed in a single session\n- No ambiguity about what \"done\" means\n- Not dependent on decisions not yet made\n\n### 2. needs_planning\nGoal, project idea, or ambiguous intention that requires breakdown before action.\n\nCriteria:\n- Expresses a goal or desired outcome rather than specific action\n- Contains multiple potential tasks\n- Requires scoping or breakdown to become actionable\n- Uses phrases like \"want to\", \"should\", \"need to figure out\"\n- Overwhelm factor would be > 7 (too complex to start immediately)\n\n### 3. archive_only\nThought, reflection, or observation with no implied action.\n\nCriteria:\n- Reflective or exploratory thought\n- No implied action or task\n- Information capture (quotes, ideas, observations)\n- Emotional processing or journaling\n\n## INPUT\n\nNote Content: ${note.content || ''}\nConcepts: ${note.concepts || '[]'}\nThemes: ${note.primary_theme || 'unknown'}\nEnergy Level: ${note.energy_level || 'unknown'}\nEmotional Tone: ${note.emotional_tone || 'neutral'}\nADHD Markers: ${note.adhd_markers || 'none'}\n\n## DECISION RULES\n\nApply these rules in order:\n\n1. **Actionable Check**\n   IF note has clear verb + specific object\n   AND can be completed in a single session\n   AND \"done\" is unambiguous\n   AND not dependent on unmade decisions\n   THEN classification = \"actionable\"\n\n2. **Needs Planning Check**\n   IF note expresses a goal or desired outcome\n   OR contains multiple potential tasks\n   OR requires scoping or breakdown\n   OR uses \"want to\", \"should\", \"need to figure out\"\n   OR overwhelm factor > 7\n   THEN classification = \"needs_planning\"\n\n3. **Archive Only (Default)**\n   IF note is reflective, observational, or captures information\n   OR no implied action\n   THEN classification = \"archive_only\"\n\n## EDGE CASE HANDLING\n\n- When in doubt between actionable and needs_planning: Choose \"needs_planning\"\n- When in doubt between needs_planning and archive_only: Choose \"archive_only\"\n\n## OUTPUT FORMAT\n\nReturn ONLY valid JSON with no additional text or explanation:\n\n{\n  \"classification\": \"actionable|needs_planning|archive_only\",\n  \"confidence\": 0.0-1.0,\n  \"reasoning\": \"Brief explanation of why this classification was chosen\"\n}\n\nBEGIN CLASSIFICATION:`;\n\nreturn {\n  json: {\n    ...note,\n    classification_prompt: prompt\n  }\n};"
      },
      "id": "build-classification-prompt",
      "name": "Build Classification Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/generate",
        "options": {
          "timeout": 30000
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"mistral:7b\",\n  \"prompt\": $json.classification_prompt,\n  \"stream\": false,\n  \"format\": \"json\",\n  \"options\": {\n    \"temperature\": 0.3,\n    \"num_predict\": 500\n  }\n} }}"
      },
      "id": "ollama-classify",
      "name": "Ollama Classify Note",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [850, 300]
    },
    {
      "parameters": {
        "functionCode": "const db = require('better-sqlite3')('/selene/data/selene.db');\n\ntry {\n  const response = $input.item.json.response;\n  const noteData = $('Build Classification Prompt').first().json;\n\n  console.log('[Parse Classification] noteData.raw_note_id:', noteData.raw_note_id);\n\n  let classification = 'archive_only';\n  let confidence = 0.5;\n  let reasoning = 'Default classification';\n\n  try {\n    const parsed = JSON.parse(response);\n    classification = parsed.classification || 'archive_only';\n    confidence = parsed.confidence || 0.5;\n    reasoning = parsed.reasoning || 'No reasoning provided';\n    \n    const validValues = ['actionable', 'needs_planning', 'archive_only'];\n    if (!validValues.includes(classification)) {\n      console.warn('[Parse Classification] Invalid classification:', classification);\n      classification = 'archive_only';\n    }\n  } catch (e) {\n    console.error('[Parse Classification] Failed to parse:', e);\n  }\n\n  console.log('[Parse Classification] Result:', classification, 'for note', noteData.raw_note_id);\n\n  // IMMEDIATELY store classification to database (failsafe)\n  const planningStatus = classification === 'needs_planning' ? 'pending_review' : null;\n  db.prepare(`\n    UPDATE processed_notes\n    SET classification = ?,\n        planning_status = ?\n    WHERE raw_note_id = ?\n  `).run(classification, planningStatus, noteData.raw_note_id);\n\n  console.log('[Parse Classification] Stored classification:', classification);\n\n  return {\n    json: {\n      ...noteData,\n      classification: classification,\n      classification_confidence: confidence,\n      classification_reasoning: reasoning\n    }\n  };\n} finally {\n  db.close();\n}"
      },
      "id": "parse-classification",
      "name": "Parse Classification",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "// Route based on classification\nconst classification = $json.classification;\nconst rawNoteId = $json.raw_note_id;\n\nconsole.log('[Route by Classification] Classification:', classification, 'raw_note_id:', rawNoteId);\nconsole.log('[Route by Classification] All keys:', Object.keys($json));\n\n// Create a clean data object to pass through\nconst data = {\n  raw_note_id: $json.raw_note_id,\n  processed_note_id: $json.processed_note_id,\n  content: $json.content,\n  tags: $json.tags,\n  concepts: $json.concepts,\n  primary_theme: $json.primary_theme,\n  themes: $json.themes,\n  energy_level: $json.energy_level,\n  emotional_tone: $json.emotional_tone,\n  adhd_markers: $json.adhd_markers,\n  test_run: $json.test_run,\n  classification: classification,\n  classification_confidence: $json.classification_confidence,\n  classification_reasoning: $json.classification_reasoning\n};\n\nconsole.log('[Route by Classification] Passing data with raw_note_id:', data.raw_note_id);\n\n// Multi-output routing:\n// Output 0: actionable\n// Output 1: needs_planning\n// Output 2: archive_only\n\nif (classification === 'actionable') {\n  return [[{json: data}], [], []];\n} else if (classification === 'needs_planning') {\n  return [[], [{json: data}], []];\n} else {\n  // archive_only or unknown defaults to archive\n  return [[], [], [{json: data}]];\n}",
        "outputs": 3
      },
      "id": "route-classification",
      "name": "Route by Classification",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 300],
      "outputs": ["main", "main", "main"]
    },
    {
      "parameters": {
        "functionCode": "// Unwrap input data (multi-output routing workaround)\nlet note = $input.item.json;\nif (Array.isArray(note)) {\n  note = note[0];\n}\nif (note && note.json) {\n  note = note.json;\n}\n\n// Guard: Only process if this is an actionable note\nif (!note || note.classification !== 'actionable') {\n  console.log('[Build Task Extraction Prompt] Skipping - not actionable:', note ? note.classification : 'no data');\n  return [];\n}\n\nconsole.log('[Build Task Extraction Prompt] Processing actionable note:', note.raw_note_id);\n\n// Build prompt - note has already been classified as actionable\nconst prompt = `You are a task extraction assistant for an ADHD-optimized productivity system.\n\nThis note has already been classified as ACTIONABLE, meaning it contains clear, specific tasks.\nExtract all actionable tasks from this note.\n\nINPUT:\nNote Content: ${note.content || ''}\nEnergy Level: ${note.energy_level || 'unknown'}\nConcepts: ${note.concepts || '[]'}\nThemes: ${note.primary_theme || 'general'}\nEmotional Tone: ${note.emotional_tone || 'neutral'}\nADHD Markers: ${note.adhd_markers || 'none'}\nClassification Reasoning: ${note.classification_reasoning || 'Classified as actionable'}\n\nINSTRUCTIONS:\n1. Extract ALL actionable tasks (things the person can DO)\n2. Each task should be specific and start with a verb\n3. Tasks should be completable in a single session\n4. Do NOT extract vague goals - those would be \"needs_planning\"\n\nFor each task, provide:\n- task_text: Clear, actionable description (start with verb, <80 characters)\n- energy_required: high/medium/low\n  * high = creative work, learning, complex decisions, writing\n  * medium = routine work, communication, light planning\n  * low = organizing, simple responses, filing, sorting\n- estimated_minutes: 5, 15, 30, 60, 120, or 240\n  * Be realistic, ADHD users often underestimate\n  * Add 25% buffer to initial estimates\n- task_type: action/decision/research/communication/learning/planning\n- context_tags: Array of relevant contexts (max 3)\n  * Common: work, personal, home, creative, technical, social, urgent, deadline\n- overwhelm_factor: 1-10 (how overwhelming this might feel)\n  * 1-3 = Simple, clear, quick\n  * 4-6 = Moderate complexity or time\n  * 7-8 = Complex but doable\n  * 9-10 = Should have been needs_planning\n\nOUTPUT FORMAT (JSON only, no explanation):\n[\n  {\n    \"task_text\": \"Write project proposal draft\",\n    \"energy_required\": \"high\",\n    \"estimated_minutes\": 60,\n    \"task_type\": \"action\",\n    \"context_tags\": [\"work\", \"writing\"],\n    \"overwhelm_factor\": 6\n  }\n]\n\nIf somehow no tasks found: []\n\nBEGIN EXTRACTION:`;\n\nreturn {\n  json: {\n    ...note,\n    prompt_text: prompt\n  }\n};"
      },
      "id": "build-prompt",
      "name": "Build Task Extraction Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1450, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/generate",
        "options": {
          "timeout": 60000
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"mistral:7b\",\n  \"prompt\": $json.prompt_text,\n  \"stream\": false,\n  \"format\": \"json\",\n  \"options\": {\n    \"temperature\": 0.3,\n    \"num_predict\": 2000\n  }\n} }}"
      },
      "id": "ollama-extract",
      "name": "Ollama Extract Tasks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1650, 100]
    },
    {
      "parameters": {
        "functionCode": "const response = $input.item.json.response;\n// Reference Build Prompt node directly (Ollama HTTP replaces input data)\nconst noteData = $('Build Task Extraction Prompt').first().json;\n\nconsole.log('[Parse Tasks] Ollama response type:', typeof response);\nconsole.log('[Parse Tasks] raw_note_id from Build Prompt:', noteData.raw_note_id);\n\nlet tasks = [];\ntry {\n  const parsed = JSON.parse(response);\n  console.log('[Parse Tasks] Parsed type:', typeof parsed, 'Is array:', Array.isArray(parsed));\n  if (Array.isArray(parsed)) {\n    tasks = parsed;\n  } else if (parsed && Array.isArray(parsed.tasks)) {\n    tasks = parsed.tasks;\n  } else {\n    tasks = [];\n  }\n  console.log('[Parse Tasks] Extracted tasks count:', tasks.length);\n} catch (e) {\n  console.error('Failed to parse Ollama response:', e);\n  return {\n    json: {\n      raw_note_id: noteData.raw_note_id,\n      processed_note_id: noteData.processed_note_id,\n      tasks: [],\n      task_count: 0,\n      classification: noteData.classification,\n      test_run: noteData.test_run,\n      error: 'Invalid JSON from Ollama'\n    }\n  };\n}\n\n// Validate and EMBED metadata into each task (so Split preserves it)\nconst validatedTasks = tasks.filter(task => {\n  return task.task_text && task.energy_required && task.estimated_minutes && task.task_type;\n}).map(task => {\n  if (!task.overwhelm_factor || task.overwhelm_factor < 1 || task.overwhelm_factor > 10) {\n    task.overwhelm_factor = 5;\n  }\n  // EMBED metadata directly into each task object\n  return {\n    ...task,\n    raw_note_id: noteData.raw_note_id,\n    processed_note_id: noteData.processed_note_id,\n    original_note: noteData.content,\n    concepts: noteData.concepts,\n    themes: noteData.primary_theme,\n    classification: noteData.classification,\n    test_run: noteData.test_run\n  };\n});\n\nconsole.log('[Parse Tasks] First task after embedding:', validatedTasks[0] ? JSON.stringify(validatedTasks[0]).substring(0, 200) : 'none');\n\nreturn {\n  json: {\n    tasks: validatedTasks,\n    task_count: validatedTasks.length,\n    raw_note_id: noteData.raw_note_id,\n    processed_note_id: noteData.processed_note_id,\n    classification: noteData.classification,\n    test_run: noteData.test_run\n  }\n};"
      },
      "id": "parse-tasks",
      "name": "Parse Tasks JSON",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1850, 100]
    },
    {
      "parameters": {
        "fieldToSplitOut": "tasks",
        "options": {}
      },
      "id": "split-tasks",
      "name": "Split Tasks",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [2050, 100]
    },
    {
      "parameters": {
        "functionCode": "const fs = require('fs');\nconst path = require('path');\n\nconst task = $input.item.json;\n\nconsole.log('[Write Things Task] Processing task:', task.task_text);\nconsole.log('[Write Things Task] raw_note_id:', task.raw_note_id);\n\nconst timestamp = Date.now();\nconst random = Math.floor(Math.random() * 10000);\nconst filename = `task-${task.raw_note_id}-${timestamp}-${random}.json`;\n\nconst thingsTask = {\n  title: task.task_text,\n  notes: `Extracted from Selene note #${task.raw_note_id}\\n\\nEnergy: ${task.energy_required}\\nEstimated: ${task.estimated_minutes}min\\nOverwhelm: ${task.overwhelm_factor}/10\\nType: ${task.task_type}\\n\\nOriginal note:\\n${(task.original_note || '').substring(0, 500)}`,\n  tags: task.context_tags || [],\n  selene_metadata: {\n    raw_note_id: task.raw_note_id,\n    processed_note_id: task.processed_note_id,\n    energy_required: task.energy_required,\n    estimated_minutes: task.estimated_minutes,\n    overwhelm_factor: task.overwhelm_factor,\n    task_type: task.task_type,\n    concepts: task.concepts,\n    themes: task.themes,\n    test_run: task.test_run\n  }\n};\n\nconst pendingDir = '/obsidian/things-pending';\nconst filePath = path.join(pendingDir, filename);\n\ntry {\n  if (!fs.existsSync(pendingDir)) {\n    fs.mkdirSync(pendingDir, { recursive: true });\n  }\n  fs.writeFileSync(filePath, JSON.stringify(thingsTask, null, 2));\n  console.log('[Write Things Task] Wrote file:', filePath);\n} catch (err) {\n  console.error('[Write Things Task] Error writing file:', err.message);\n  throw err;\n}\n\nreturn {\n  json: {\n    task: task,\n    raw_note_id: task.raw_note_id,\n    processed_note_id: task.processed_note_id,\n    things_file: filename,\n    concepts: task.concepts,\n    themes: task.themes,\n    test_run: task.test_run\n  }\n};"
      },
      "id": "create-things-task",
      "name": "Write Things Task File",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2250, 100]
    },
    {
      "parameters": {
        "functionCode": "const db = require('better-sqlite3')('/selene/data/selene.db');\n\ntry {\n  // Debug: Log all available data\n  console.log('[Store Task] $json:', JSON.stringify($json, null, 2));\n  console.log('[Store Task] $input.item.json:', JSON.stringify($input.item.json, null, 2));\n\n  // Try to get data from input item (from Write Things Task File node)\n  const inputData = $input.item.json;\n  console.log('[Store Task] Input keys:', Object.keys(inputData || {}));\n\n  // Reference data from wherever it is\n  let task, rawNoteId, processedNoteId, concepts, themes, testRun, thingsFile;\n  if (inputData.task) {\n    // Data came through properly from Write Things Task File node\n    task = inputData.task;\n    rawNoteId = inputData.raw_note_id || inputData.task.raw_note_id;\n    processedNoteId = inputData.processed_note_id || inputData.task.processed_note_id;\n    concepts = inputData.concepts || inputData.task.concepts;\n    themes = inputData.themes || inputData.task.themes;\n    testRun = inputData.test_run || inputData.task.test_run;\n    thingsFile = inputData.things_file;\n  } else {\n    console.error('[Store Task] ERROR: Could not find task data!');\n    throw new Error('Task data not found in input');\n  }\n\n  console.log('[Store Task] Got data:', { rawNoteId, taskText: task?.task_text, thingsFile });\n\n  // Generate simple unique ID without crypto module\n  const generateUniqueId = () => {\n    const timestamp = Date.now();\n    const random = Math.floor(Math.random() * 1000000);\n    return `selene-${timestamp}-${random}`;\n  };\n\n  // Use things_file as the identifier, or generate one if missing\n  const finalThingsTaskId = thingsFile || generateUniqueId();\n\n  console.log('[Store Task] Things task_id (from file):', finalThingsTaskId);\n\n  // Check if task_metadata table exists, create if not\n  const tableExists = db.prepare(`\n    SELECT name FROM sqlite_master WHERE type='table' AND name='task_metadata'\n  `).get();\n\n  if (!tableExists) {\n    db.prepare(`\n      CREATE TABLE task_metadata (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        raw_note_id INTEGER NOT NULL,\n        things_task_id TEXT,\n        energy_required TEXT,\n        estimated_minutes INTEGER,\n        related_concepts TEXT,\n        related_themes TEXT,\n        overwhelm_factor INTEGER,\n        task_type TEXT,\n        context_tags TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        test_run TEXT,\n        FOREIGN KEY (raw_note_id) REFERENCES raw_notes(id)\n      )\n    `).run();\n  }\n\n  db.prepare(`\n    INSERT INTO task_metadata (\n      raw_note_id, things_task_id, energy_required, estimated_minutes,\n      related_concepts, related_themes, overwhelm_factor, task_type, context_tags, test_run\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n  `).run(\n    rawNoteId,\n    finalThingsTaskId,\n    task.energy_required,\n    task.estimated_minutes,\n    JSON.stringify(concepts || []),\n    JSON.stringify(themes || []),\n    task.overwhelm_factor,\n    task.task_type,\n    JSON.stringify(task.context_tags || []),\n    testRun || null\n  );\n\n  console.log('[Store Task] Successfully stored task metadata for note', rawNoteId);\n\n  return {\n    json: {\n      raw_note_id: rawNoteId,\n      processed_note_id: processedNoteId,\n      things_task_id: finalThingsTaskId,\n      task_text: task.task_text,\n      test_run: testRun\n    }\n  };\n} finally {\n  db.close();\n}"
      },
      "id": "store-metadata",
      "name": "Store Task Metadata",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2450, 100]
    },
    {
      "parameters": {
        "functionCode": "const db = require('better-sqlite3')('/selene/data/selene.db');\n\ntry {\n  const rawNoteId = $input.first().json.raw_note_id;\n  const processedNoteId = $input.first().json.processed_note_id;\n  const taskCount = $input.all().length;\n  const testRun = $input.first().json.test_run;\n\n  // Update raw_notes\n  db.prepare(`\n    UPDATE raw_notes\n    SET tasks_extracted = 1,\n        tasks_extracted_at = CURRENT_TIMESTAMP\n    WHERE id = ?\n  `).run(rawNoteId);\n\n  // Update processed_notes with classification and status\n  const status = taskCount > 0 ? 'tasks_created' : 'no_tasks';\n  db.prepare(`\n    UPDATE processed_notes\n    SET things_integration_status = ?,\n        classification = 'actionable'\n    WHERE id = ? OR raw_note_id = ?\n  `).run(status, processedNoteId, rawNoteId);\n\n  console.log('[Update Status - Actionable] Updated note', rawNoteId, 'with', taskCount, 'tasks');\n\n  return {\n    json: {\n      success: true,\n      raw_note_id: rawNoteId,\n      processed_note_id: processedNoteId,\n      tasks_created: taskCount,\n      classification: 'actionable',\n      test_run: testRun\n    }\n  };\n} finally {\n  db.close();\n}"
      },
      "id": "update-status-actionable",
      "name": "Update Status (Actionable)",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2650, 100]
    },
    {
      "parameters": {
        "functionCode": "// Unwrap input data (multi-output routing workaround)\nlet data = $input.item.json;\nif (Array.isArray(data)) {\n  data = data[0];\n}\nif (data && data.json) {\n  data = data.json;\n}\n\n// Guard: Only process if this is a needs_planning note\nif (!data || data.classification !== 'needs_planning') {\n  console.log('[Flag for Planning] Skipping - not needs_planning:', data ? data.classification : 'no data');\n  return [];\n}\n\nconst db = require('better-sqlite3')('/selene/data/selene.db');\n\ntry {\n  const rawNoteId = data.raw_note_id;\n  const processedNoteId = data.processed_note_id;\n  const testRun = data.test_run;\n  const content = data.content;\n  const concepts = data.concepts;\n  const classificationReasoning = data.classification_reasoning;\n\n  console.log('[Flag for Planning] Processing note', rawNoteId);\n\n  // Update processed_notes with classification and planning_status\n  db.prepare(`\n    UPDATE processed_notes\n    SET classification = 'needs_planning',\n        planning_status = 'pending_review'\n    WHERE id = ? OR raw_note_id = ?\n  `).run(processedNoteId, rawNoteId);\n\n  // Get processed_note_id if not already available\n  let pnId = processedNoteId;\n  if (!pnId) {\n    const row = db.prepare('SELECT id FROM processed_notes WHERE raw_note_id = ?').get(rawNoteId);\n    pnId = row ? row.id : null;\n  }\n\n  // Create discussion thread for SeleneChat (Phase 7.2 prep)\n  // Generate a planning prompt based on the note content\n  const planningPrompt = `This note needs breakdown into actionable tasks: \"${(content || '').substring(0, 200)}...\"`;\n\n  db.prepare(`\n    INSERT INTO discussion_threads (raw_note_id, thread_type, prompt, status, related_concepts, test_run)\n    VALUES (?, 'planning', ?, 'pending', ?, ?)\n  `).run(\n    rawNoteId,\n    planningPrompt,\n    JSON.stringify(concepts || []),\n    testRun || null\n  );\n\n  console.log('[Flag for Planning] Created discussion thread for note', rawNoteId);\n\n  return {\n    json: {\n      success: true,\n      raw_note_id: rawNoteId,\n      processed_note_id: pnId,\n      classification: 'needs_planning',\n      planning_status: 'pending_review',\n      discussion_thread_created: true,\n      test_run: testRun\n    }\n  };\n} finally {\n  db.close();\n}"
      },
      "id": "flag-for-planning",
      "name": "Flag for Planning",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "functionCode": "// Unwrap input data (multi-output routing workaround)\nlet data = $input.item.json;\nif (Array.isArray(data)) {\n  data = data[0];\n}\nif (data && data.json) {\n  data = data.json;\n}\n\n// Guard: Only process if this is an archive_only note\nif (!data || data.classification !== 'archive_only') {\n  console.log('[Store Classification] Skipping - not archive_only:', data ? data.classification : 'no data');\n  return [];\n}\n\nconst db = require('better-sqlite3')('/selene/data/selene.db');\n\ntry {\n  const rawNoteId = data.raw_note_id;\n  const processedNoteId = data.processed_note_id;\n  const classification = data.classification;\n  const confidence = data.classification_confidence;\n  const testRun = data.test_run;\n\n  console.log('[Store Classification] Processing note', rawNoteId);\n\n  // Update processed_notes with classification only (archive_only path)\n  db.prepare(`\n    UPDATE processed_notes\n    SET classification = 'archive_only',\n        planning_status = NULL\n    WHERE id = ? OR raw_note_id = ?\n  `).run(processedNoteId, rawNoteId);\n\n  console.log('[Store Classification] Updated note', rawNoteId, 'as archive_only');\n\n  return {\n    json: {\n      success: true,\n      raw_note_id: rawNoteId,\n      processed_note_id: processedNoteId,\n      classification: 'archive_only',\n      classification_stored: true,\n      test_run: testRun\n    }\n  };\n} finally {\n  db.close();\n}"
      },
      "id": "store-classification",
      "name": "Store Classification (Archive)",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1450, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{ "node": "Fetch Note Data", "type": "main", "index": 0 }]]
    },
    "Fetch Note Data": {
      "main": [[{ "node": "Build Classification Prompt", "type": "main", "index": 0 }]]
    },
    "Build Classification Prompt": {
      "main": [[{ "node": "Ollama Classify Note", "type": "main", "index": 0 }]]
    },
    "Ollama Classify Note": {
      "main": [[{ "node": "Parse Classification", "type": "main", "index": 0 }]]
    },
    "Parse Classification": {
      "main": [[{ "node": "Route by Classification", "type": "main", "index": 0 }]]
    },
    "Route by Classification": {
      "main": [
        [{ "node": "Build Task Extraction Prompt", "type": "main", "index": 0 }],
        [{ "node": "Flag for Planning", "type": "main", "index": 0 }],
        [{ "node": "Store Classification (Archive)", "type": "main", "index": 0 }]
      ]
    },
    "Build Task Extraction Prompt": {
      "main": [[{ "node": "Ollama Extract Tasks", "type": "main", "index": 0 }]]
    },
    "Ollama Extract Tasks": {
      "main": [[{ "node": "Parse Tasks JSON", "type": "main", "index": 0 }]]
    },
    "Parse Tasks JSON": {
      "main": [[{ "node": "Split Tasks", "type": "main", "index": 0 }]]
    },
    "Split Tasks": {
      "main": [[{ "node": "Write Things Task File", "type": "main", "index": 0 }]]
    },
    "Write Things Task File": {
      "main": [[{ "node": "Store Task Metadata", "type": "main", "index": 0 }]]
    },
    "Store Task Metadata": {
      "main": [[{ "node": "Update Status (Actionable)", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "executionTimeout": 300,
    "timezone": "America/Los_Angeles"
  },
  "staticData": null,
  "tags": [
    {
      "name": "Selene",
      "id": "selene-tag"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-12-30T00:00:00.000Z",
  "versionId": "2"
}
