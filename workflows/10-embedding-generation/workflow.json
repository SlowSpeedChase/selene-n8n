{
  "name": "10-Embedding-Generation | Selene",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/embed",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-embed",
      "name": "Webhook: Embed Notes",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "selene-embed-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Normalize input: accept note_id (single) or note_ids (array)\nconst body = $input.item.json.body || $input.item.json;\n\nlet noteIds = [];\n\nif (body.note_ids && Array.isArray(body.note_ids)) {\n  noteIds = body.note_ids;\n} else if (body.note_id) {\n  noteIds = [body.note_id];\n} else {\n  throw new Error('Must provide note_id or note_ids');\n}\n\n// Filter to integers only\nnoteIds = noteIds.map(id => parseInt(id, 10)).filter(id => !isNaN(id));\n\nif (noteIds.length === 0) {\n  throw new Error('No valid note IDs provided');\n}\n\nconst testRun = body.test_run || null;\n\nconsole.log('[Normalize Input] Processing', noteIds.length, 'note(s)');\n\nreturn {\n  json: {\n    note_ids: noteIds,\n    test_run: testRun,\n    total_count: noteIds.length\n  }\n};"
      },
      "id": "normalize-input",
      "name": "Normalize Input",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "// Split note_ids array into individual items for processing\nconst data = $json;\nconst noteIds = data.note_ids;\nconst testRun = data.test_run;\nconst totalCount = data.total_count;\n\nreturn noteIds.map(id => ({\n  json: {\n    note_id: id,\n    test_run: testRun,\n    total_count: totalCount\n  }\n}));"
      },
      "id": "split-batches",
      "name": "Split Into Items",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\nlet db;\n\ntry {\n  const noteId = $json.note_id;\n  const testRun = $json.test_run;\n  const totalCount = $json.total_count;\n  \n  db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  const row = db.prepare(`\n    SELECT id, content, title\n    FROM raw_notes\n    WHERE id = ?\n  `).get(noteId);\n  \n  db.close();\n  \n  if (!row) {\n    console.warn('[Fetch Note] Note not found:', noteId);\n    return {\n      json: {\n        note_id: noteId,\n        found: false,\n        content: null,\n        test_run: testRun,\n        total_count: totalCount\n      }\n    };\n  }\n  \n  // Combine title and content for embedding\n  const textToEmbed = row.title ? `${row.title}\\n\\n${row.content}` : row.content;\n  \n  return {\n    json: {\n      note_id: noteId,\n      found: true,\n      content: textToEmbed,\n      test_run: testRun,\n      total_count: totalCount\n    }\n  };\n  \n} catch (error) {\n  if (db) db.close();\n  console.error('[Fetch Note] Error:', error.message);\n  throw error;\n}"
      },
      "id": "fetch-note",
      "name": "Fetch Note Content",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.found }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-found",
      "name": "Note Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\nlet db;\n\ntry {\n  const noteId = $json.note_id;\n  const content = $json.content;\n  const testRun = $json.test_run;\n  const totalCount = $json.total_count;\n  \n  db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  const existing = db.prepare(`\n    SELECT id FROM note_embeddings WHERE raw_note_id = ?\n  `).get(noteId);\n  \n  db.close();\n  \n  return {\n    json: {\n      note_id: noteId,\n      content: content,\n      has_embedding: !!existing,\n      test_run: testRun,\n      total_count: totalCount\n    }\n  };\n  \n} catch (error) {\n  if (db) db.close();\n  console.error('[Check Embedding] Error:', error.message);\n  throw error;\n}"
      },
      "id": "check-embedding",
      "name": "Check Existing Embedding",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_embedding }}",
              "value2": false
            }
          ]
        }
      },
      "id": "route-embedding",
      "name": "Needs Embedding?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/embeddings",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"nomic-embed-text\",\n  \"prompt\": $json.content\n} }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-ollama",
      "name": "Call Ollama Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1650, 100],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\nlet db;\n\ntry {\n  const ollamaResult = $json;\n  const noteData = $('Needs Embedding?').item.json;\n  \n  if (!ollamaResult.embedding || !Array.isArray(ollamaResult.embedding)) {\n    console.error('[Store Embedding] Invalid embedding response');\n    return {\n      json: {\n        note_id: noteData.note_id,\n        status: 'failed',\n        error: 'Invalid embedding response from Ollama',\n        test_run: noteData.test_run,\n        total_count: noteData.total_count\n      }\n    };\n  }\n  \n  const embedding = ollamaResult.embedding;\n  const dimensions = embedding.length;\n  \n  console.log('[Store Embedding] Storing', dimensions, 'dimensions for note', noteData.note_id);\n  \n  db = new Database('/selene/data/selene.db');\n  \n  // Store embedding as JSON blob\n  const embeddingJson = JSON.stringify(embedding);\n  \n  db.prepare(`\n    INSERT OR REPLACE INTO note_embeddings (raw_note_id, embedding, model_version, test_run)\n    VALUES (?, ?, ?, ?)\n  `).run(\n    noteData.note_id,\n    embeddingJson,\n    'nomic-embed-text',\n    noteData.test_run\n  );\n  \n  db.close();\n  \n  return {\n    json: {\n      note_id: noteData.note_id,\n      status: 'embedded',\n      dimensions: dimensions,\n      test_run: noteData.test_run,\n      total_count: noteData.total_count\n    }\n  };\n  \n} catch (error) {\n  if (db) db.close();\n  console.error('[Store Embedding] Error:', error.message);\n  return {\n    json: {\n      note_id: $('Needs Embedding?').item.json.note_id,\n      status: 'failed',\n      error: error.message,\n      test_run: $('Needs Embedding?').item.json.test_run,\n      total_count: $('Needs Embedding?').item.json.total_count\n    }\n  };\n}"
      },
      "id": "store-embedding",
      "name": "Store Embedding",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1850, 100]
    },
    {
      "parameters": {
        "functionCode": "// Handle Ollama error\nconst noteData = $('Needs Embedding?').item.json;\nconst error = $json.error || 'Ollama request failed';\n\nconsole.error('[Ollama Error] Failed for note', noteData.note_id, ':', error);\n\nreturn {\n  json: {\n    note_id: noteData.note_id,\n    status: 'failed',\n    error: error,\n    test_run: noteData.test_run,\n    total_count: noteData.total_count\n  }\n};"
      },
      "id": "ollama-error",
      "name": "Handle Ollama Error",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1850, 250]
    },
    {
      "parameters": {
        "functionCode": "// Mark as skipped (already has embedding)\nconst noteData = $json;\n\nconsole.log('[Skip] Note', noteData.note_id, 'already has embedding');\n\nreturn {\n  json: {\n    note_id: noteData.note_id,\n    status: 'skipped',\n    reason: 'already_embedded',\n    test_run: noteData.test_run,\n    total_count: noteData.total_count\n  }\n};"
      },
      "id": "mark-skipped",
      "name": "Mark Skipped",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Mark as not found\nconst noteData = $json;\n\nconsole.log('[Not Found] Note', noteData.note_id, 'does not exist');\n\nreturn {\n  json: {\n    note_id: noteData.note_id,\n    status: 'not_found',\n    test_run: noteData.test_run,\n    total_count: noteData.total_count\n  }\n};"
      },
      "id": "mark-not-found",
      "name": "Mark Not Found",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "functionCode": "// Aggregate all results into summary\nconst items = $input.all();\n\nlet embedded = 0;\nlet skipped = 0;\nlet notFound = 0;\nlet failed = 0;\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  results.push({\n    note_id: data.note_id,\n    status: data.status,\n    error: data.error || null,\n    dimensions: data.dimensions || null\n  });\n  \n  switch (data.status) {\n    case 'embedded':\n      embedded++;\n      break;\n    case 'skipped':\n      skipped++;\n      break;\n    case 'not_found':\n      notFound++;\n      break;\n    case 'failed':\n      failed++;\n      break;\n  }\n}\n\nconst totalProcessed = items.length;\n\nreturn {\n  json: {\n    success: failed === 0,\n    summary: {\n      total: totalProcessed,\n      embedded: embedded,\n      skipped: skipped,\n      not_found: notFound,\n      failed: failed\n    },\n    results: results\n  }\n};"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2250, 200]
    }
  ],
  "connections": {
    "Webhook: Embed Notes": {
      "main": [
        [
          {
            "node": "Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Input": {
      "main": [
        [
          {
            "node": "Split Into Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Items": {
      "main": [
        [
          {
            "node": "Fetch Note Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Note Content": {
      "main": [
        [
          {
            "node": "Note Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Note Found?": {
      "main": [
        [
          {
            "node": "Check Existing Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mark Not Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Existing Embedding": {
      "main": [
        [
          {
            "node": "Needs Embedding?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Embedding?": {
      "main": [
        [
          {
            "node": "Call Ollama Embeddings",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mark Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Ollama Embeddings": {
      "main": [
        [
          {
            "node": "Store Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Ollama Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Embedding": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Ollama Error": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Skipped": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Not Found": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1
}
