{
  "name": "11-Association-Computation | Selene",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/associate",
        "responseMode": "lastNode",
        "options": {}
      },
      "id": "webhook-associate",
      "name": "Webhook: Compute Associations",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "selene-associate-webhook"
    },
    {
      "parameters": {
        "functionCode": "// Normalize input: accept note_id (single) or note_ids (array)\nconst body = $input.item.json.body || $input.item.json;\n\nlet noteIds = [];\n\nif (body.note_ids && Array.isArray(body.note_ids)) {\n  noteIds = body.note_ids;\n} else if (body.note_id) {\n  noteIds = [body.note_id];\n} else {\n  throw new Error('Must provide note_id or note_ids');\n}\n\n// Filter to integers only\nnoteIds = noteIds.map(id => parseInt(id, 10)).filter(id => !isNaN(id));\n\nif (noteIds.length === 0) {\n  throw new Error('No valid note IDs provided');\n}\n\nconst testRun = body.test_run || null;\n\nconsole.log('[Normalize Input] Processing', noteIds.length, 'note(s) for associations');\n\nreturn {\n  json: {\n    note_ids: noteIds,\n    test_run: testRun,\n    total_count: noteIds.length\n  }\n};"
      },
      "id": "normalize-input",
      "name": "Normalize Input",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "functionCode": "// Split note_ids array into individual items for processing\nconst data = $json;\nconst noteIds = data.note_ids;\nconst testRun = data.test_run;\nconst totalCount = data.total_count;\n\nreturn noteIds.map(id => ({\n  json: {\n    note_id: id,\n    test_run: testRun,\n    total_count: totalCount\n  }\n}));"
      },
      "id": "split-batches",
      "name": "Split Into Items",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\nlet db;\n\ntry {\n  const noteId = $json.note_id;\n  const testRun = $json.test_run;\n  const totalCount = $json.total_count;\n  \n  db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  const row = db.prepare(`\n    SELECT raw_note_id, embedding\n    FROM note_embeddings\n    WHERE raw_note_id = ?\n  `).get(noteId);\n  \n  db.close();\n  \n  if (!row) {\n    console.warn('[Fetch Embedding] No embedding for note:', noteId);\n    return {\n      json: {\n        note_id: noteId,\n        has_embedding: false,\n        embedding: null,\n        test_run: testRun,\n        total_count: totalCount\n      }\n    };\n  }\n  \n  // Parse embedding from JSON string\n  const embedding = JSON.parse(row.embedding);\n  \n  return {\n    json: {\n      note_id: noteId,\n      has_embedding: true,\n      embedding: embedding,\n      test_run: testRun,\n      total_count: totalCount\n    }\n  };\n  \n} catch (error) {\n  if (db) db.close();\n  console.error('[Fetch Embedding] Error:', error.message);\n  throw error;\n}"
      },
      "id": "fetch-source-embedding",
      "name": "Fetch Source Embedding",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_embedding }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-has-embedding",
      "name": "Has Embedding?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\nlet db;\n\ntry {\n  const sourceNoteId = $json.note_id;\n  const sourceEmbedding = $json.embedding;\n  const testRun = $json.test_run;\n  const totalCount = $json.total_count;\n  \n  // Configuration\n  const SIMILARITY_THRESHOLD = 0.7;\n  const MAX_ASSOCIATIONS = 20;\n  \n  // Cosine similarity function\n  function cosineSimilarity(vecA, vecB) {\n    let dotProduct = 0, normA = 0, normB = 0;\n    for (let i = 0; i < vecA.length; i++) {\n      dotProduct += vecA[i] * vecB[i];\n      normA += vecA[i] * vecA[i];\n      normB += vecB[i] * vecB[i];\n    }\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n  \n  db = new Database('/selene/data/selene.db', { readonly: true });\n  \n  // Load all other embeddings\n  const rows = db.prepare(`\n    SELECT raw_note_id, embedding\n    FROM note_embeddings\n    WHERE raw_note_id != ?\n  `).all(sourceNoteId);\n  \n  db.close();\n  \n  console.log('[Compute Similarities] Comparing note', sourceNoteId, 'against', rows.length, 'other notes');\n  \n  // Compute similarities\n  const candidates = [];\n  \n  for (const row of rows) {\n    const otherEmbedding = JSON.parse(row.embedding);\n    const similarity = cosineSimilarity(sourceEmbedding, otherEmbedding);\n    \n    if (similarity >= SIMILARITY_THRESHOLD) {\n      candidates.push({\n        target_note_id: row.raw_note_id,\n        similarity: similarity\n      });\n    }\n  }\n  \n  // Sort by similarity descending, take top N\n  candidates.sort((a, b) => b.similarity - a.similarity);\n  const topAssociations = candidates.slice(0, MAX_ASSOCIATIONS);\n  \n  console.log('[Compute Similarities] Found', candidates.length, 'above threshold,', 'keeping top', topAssociations.length);\n  \n  return {\n    json: {\n      note_id: sourceNoteId,\n      associations: topAssociations,\n      total_candidates: candidates.length,\n      threshold: SIMILARITY_THRESHOLD,\n      max_kept: MAX_ASSOCIATIONS,\n      test_run: testRun,\n      total_count: totalCount\n    }\n  };\n  \n} catch (error) {\n  if (db) db.close();\n  console.error('[Compute Similarities] Error:', error.message);\n  throw error;\n}"
      },
      "id": "compute-similarities",
      "name": "Compute Similarities",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 200]
    },
    {
      "parameters": {
        "functionCode": "const Database = require('better-sqlite3');\nlet db;\n\ntry {\n  const sourceNoteId = $json.note_id;\n  const associations = $json.associations;\n  const testRun = $json.test_run;\n  const totalCount = $json.total_count;\n  const totalCandidates = $json.total_candidates;\n  \n  db = new Database('/selene/data/selene.db');\n  \n  // Prepare statement for inserting/updating associations\n  // Convention: note_a_id < note_b_id to prevent duplicates\n  const insertStmt = db.prepare(`\n    INSERT OR REPLACE INTO note_associations \n      (note_a_id, note_b_id, similarity_score, updated_at)\n    VALUES (?, ?, ?, CURRENT_TIMESTAMP)\n  `);\n  \n  let stored = 0;\n  \n  for (const assoc of associations) {\n    // Ensure note_a_id < note_b_id\n    const noteA = Math.min(sourceNoteId, assoc.target_note_id);\n    const noteB = Math.max(sourceNoteId, assoc.target_note_id);\n    \n    insertStmt.run(noteA, noteB, assoc.similarity);\n    stored++;\n  }\n  \n  db.close();\n  \n  console.log('[Store Associations] Stored', stored, 'associations for note', sourceNoteId);\n  \n  return {\n    json: {\n      note_id: sourceNoteId,\n      status: 'computed',\n      associations_stored: stored,\n      total_candidates: totalCandidates,\n      test_run: testRun,\n      total_count: totalCount\n    }\n  };\n  \n} catch (error) {\n  if (db) db.close();\n  console.error('[Store Associations] Error:', error.message);\n  return {\n    json: {\n      note_id: $json.note_id,\n      status: 'failed',\n      error: error.message,\n      test_run: $json.test_run,\n      total_count: $json.total_count\n    }\n  };\n}"
      },
      "id": "store-associations",
      "name": "Store Associations",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1450, 200]
    },
    {
      "parameters": {
        "functionCode": "// Mark as skipped (no embedding)\nconst noteData = $json;\n\nconsole.log('[Skip] Note', noteData.note_id, 'has no embedding');\n\nreturn {\n  json: {\n    note_id: noteData.note_id,\n    status: 'skipped',\n    reason: 'no_embedding',\n    test_run: noteData.test_run,\n    total_count: noteData.total_count\n  }\n};"
      },
      "id": "mark-skipped",
      "name": "Mark Skipped",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "functionCode": "// Aggregate all results into summary\nconst items = $input.all();\n\nlet computed = 0;\nlet skipped = 0;\nlet failed = 0;\nlet totalAssociations = 0;\nconst results = [];\n\nfor (const item of items) {\n  const data = item.json;\n  results.push({\n    note_id: data.note_id,\n    status: data.status,\n    associations_stored: data.associations_stored || 0,\n    error: data.error || null\n  });\n  \n  switch (data.status) {\n    case 'computed':\n      computed++;\n      totalAssociations += data.associations_stored || 0;\n      break;\n    case 'skipped':\n      skipped++;\n      break;\n    case 'failed':\n      failed++;\n      break;\n  }\n}\n\nconst totalProcessed = items.length;\n\nreturn {\n  json: {\n    success: failed === 0,\n    summary: {\n      total: totalProcessed,\n      computed: computed,\n      skipped: skipped,\n      failed: failed,\n      total_associations_stored: totalAssociations\n    },\n    results: results\n  }\n};"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1750, 300]
    }
  ],
  "connections": {
    "Webhook: Compute Associations": {
      "main": [
        [
          {
            "node": "Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Input": {
      "main": [
        [
          {
            "node": "Split Into Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Items": {
      "main": [
        [
          {
            "node": "Fetch Source Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Source Embedding": {
      "main": [
        [
          {
            "node": "Has Embedding?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Embedding?": {
      "main": [
        [
          {
            "node": "Compute Similarities",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Mark Skipped",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Similarities": {
      "main": [
        [
          {
            "node": "Store Associations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Associations": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Skipped": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1
}
